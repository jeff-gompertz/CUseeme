<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>c_centerpush_loadrandom2_FullAutoHUD_clean</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --hud-bg: rgba(10,10,10,.55);
    --hud-fg: #e6f3ff;
    --hud-ac: #98d5ff;
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden;}
  canvas{display:block;touch-action:none}
  #hud{
    position:fixed;top:10px;left:10px;z-index:10;
    padding:12px 14px;border-radius:8px;
    background:var(--hud-bg);color:var(--hud-fg);
    font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    backdrop-filter: blur(6px);
    user-select:none;width:320px;
    transition:opacity .4s ease,background .6s ease;
  }

    /* When HUD is dimmed/hidden */
  #hud.hidden {
    opacity: 0.15;
  }

  /* Keep the HUD toggle button bright and clickable even when dimmed */
  #hud.hidden #toggleHUD {
    opacity: 1 !important;
    background: rgba(255,255,255,0.12) !important;
    border-color: rgba(255,255,255,0.35) !important;
  }

  #hud h1 {
    margin: 0 0 8px;
    font-size: 13px;
    font-weight: 600;
    color: var(--hud-ac);
  }

  .row {
    display: grid;
    grid-template-columns: 115px 1fr 46px;
    gap: 8px;
    align-items: center;
    margin: 5px 0;
  }

  .row label {
    opacity: 0.9;
  }

  .row input[type="range"] {
    width: 100%;
  }

  .readout {
    margin-top: 10px;
    padding-top: 8px;
    border-top: 1px solid rgba(255,255,255,0.1);
    font-size: 11px;
    line-height: 1.5;
    opacity: 0.8;
    white-space: pre;
  }
  


  
  .btnline{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  .btn{
    background:rgba(255,255,255,.08);color:var(--hud-fg);
    border:1px solid rgba(255,255,255,.16);
    padding:5px 10px;border-radius:6px;cursor:pointer;
    font-size:12px;letter-spacing:.03em;
  }
  .btn:hover{background:rgba(255,255,255,.14);}
  #flash{
    position:fixed;inset:0;background:rgba(255,255,255,0);
    pointer-events:none;z-index:5;transition:background .5s ease;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="flash"></div>

<div id="hud">
  <h1>HUD Controls</h1>

  <div class="row"><label>CENTER_OVERLAP</label><input id="r1" type="range" min="0" max="400" value="0"/><output id="o1">0</output></div>
  <div class="row"><label>EDGE_PADDING</label><input id="r2" type="range" min="0" max="300" value="300"/><output id="o2">300</output></div>
  <div class="row"><label>NUM_CARDS</label><input id="r3" type="range" min="2" max="16" step="2" value="8"/><output id="o3">8</output></div>
  <div class="row"><label>ALPHA</label><input id="r4" type="range" min="0" max="1" step="0.01" value="0.35"/><output id="o4">0.35</output></div>
  <div class="row"><label>STAGGER_X</label><input id="r5" type="range" min="0" max="120" value="20"/><output id="o5">20</output></div>
  <div class="row"><label>SPINE_SHIFT</label><input id="r6" type="range" min="-100" max="100" value="26"/><output id="o6">26</output></div>
  <div class="row"><label>DEPTH_RANGE</label><input id="r7" type="range" min="0" max="1" step="0.01" value="0.76"/><output id="o7">0.76</output></div>
  <div class="row"><label>VIDEO_SCALE</label><input id="r8" type="range" min="0.8" max="1.5" step="0.01" value="1.5"/><output id="o8">1.5</output></div>

  <div class="btnline">
    <button class="btn" id="toggleHUD">HUD</button>
    <button class="btn" id="autoHUD">AUTO</button>
    <button class="btn" id="resetHUD">RESET</button>
  </div>

  <div class="readout" id="readout"></div>
</div>

<script>
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
function resize(){canvas.width=innerWidth;canvas.height=innerHeight;}
window.addEventListener("resize",resize);resize();

/* === Parameters === */
let CENTER_OVERLAP=0,EDGE_PADDING=300,NUM_CARDS=8,ALPHA=0.35,STAGGER_X=20,SPINE_SHIFT=26,DEPTH_RANGE=0.76,VIDEO_SCALE=1.5;
let currentVideo=null,activeFade=null,cards=[],autoMode=false;

/* === Auto modulation settings === */
const autoMod={
  CENTER_OVERLAP:{base:220,range:70,speed:0.001,offset:0},
  EDGE_PADDING:{base:80,range:50,speed:0.0008,offset:1000},
  STAGGER_X:{base:40,range:30,speed:0.0012,offset:2000},
  SPINE_SHIFT:{base:0,range:60,speed:0.001,offset:3000}
};

/* === Load random WP video === */
async function loadRandomVideo(){
  const API="https://art.jeffgompertz.site/wp-json/wp/v2/media?per_page=100";
  try{
    const r=await fetch(API);
    const d=await r.json();
    const vids=d.filter(m=>m.mime_type?.startsWith("video/")||/\\.mp4$/i.test(m.source_url));
    if(!vids.length)return null;
    const m=vids[Math.floor(Math.random()*vids.length)];
    const v=document.createElement("video");
    v.src=m.source_url;v.loop=true;v.muted=true;v.playsInline=true;v.preload="auto";v.style.display="none";
    document.body.appendChild(v);
    await new Promise(res=>{const ok=()=>res();v.oncanplay=ok;v.onerror=ok;setTimeout(ok,1200);});
    v.play().catch(()=>{});
    return v;
  }catch(e){console.warn("Video load error:",e);return null;}
}

/* === Init cards === */
function initCards(vid){
  const W=canvas.width,H=canvas.height;
  const w=W/2+CENTER_OVERLAP,h=H;
  cards=[];
  const perSide=NUM_CARDS/2;
  for(let i=0;i<NUM_CARDS;i++){
    const side=i<perSide?"left":"right";
    const idx=i%perSide;
    const t=idx/(perSide-1);
    const inward=(Math.random()-0.5)*STAGGER_X;
    const yOff=(Math.random()-0.5)*40;
    let xBase;
    if(side==="left"){
      const edge=0-EDGE_PADDING;
      const center=(W/2 - w/2)+CENTER_OVERLAP/2 + SPINE_SHIFT;
      xBase=edge+(center-edge)*t + inward;
    }else{
      const edge=W - w + EDGE_PADDING;
      const center=(W/2 - w/2) - CENTER_OVERLAP/2 + SPINE_SHIFT;
      xBase=edge+(center-edge)*t + inward;
    }
    cards.push({x:xBase,y:yOff,w,h,side,vid:vid,alpha:ALPHA - Math.random()*DEPTH_RANGE});
  }
}

/* === Draw === */
function drawVideo(v,c,a=1){
  if(!v||v.readyState<2)return;
  const {x,y,w,h,alpha}=c;
  const iw=v.videoWidth||v.width, ih=v.videoHeight||v.height;
  const r=Math.max((w/iw)*VIDEO_SCALE,(h/ih)*VIDEO_SCALE);
  const nw=iw*r, nh=ih*r;
  const ox=x+(w-nw)/2, oy=y+(h-nh)/2;
  ctx.globalAlpha=a*alpha;
  ctx.drawImage(v,ox,oy,nw,nh);
  ctx.globalAlpha=1;
}

/* === Fade === */
function triggerFade(oldVid,newVid){activeFade={oldVid,newVid,progress:0};}

/* === Double-tap → next video === */
let sceneAdvancing=false,lastTap=0;
async function handleAdvance(e){
  const now=Date.now(),d=now-lastTap;
  if(d<400&&!sceneAdvancing){
    sceneAdvancing=true;
    const newVid=await loadRandomVideo();
    if(newVid)triggerFade(currentVideo,newVid);
    sceneAdvancing=false;
    e.preventDefault();
  }
  lastTap=now;
}
canvas.addEventListener("touchstart",handleAdvance,{passive:false});
canvas.addEventListener("click",handleAdvance);

/* === HUD unified setup === */
const sliders=[r1,r2,r3,r4,r5,r6,r7,r8];
const outs=[o1,o2,o3,o4,o5,o6,o7,o8];
const hud=document.getElementById("hud");
const flash=document.getElementById("flash");
const toggleBtn=document.getElementById("toggleHUD");
const resetBtn=document.getElementById("resetHUD");
const autoBtn=document.getElementById("autoHUD");
const readout=document.getElementById("readout");

for(let i=0;i<sliders.length;i++){
  sliders[i].oninput=()=>{
    outs[i].value=sliders[i].value;
    [CENTER_OVERLAP,EDGE_PADDING,NUM_CARDS,ALPHA,STAGGER_X,SPINE_SHIFT,DEPTH_RANGE,VIDEO_SCALE] =
      sliders.map(s=>parseFloat(s.value));
    initCards(currentVideo);
  };
}

function updateHUD(){
  readout.textContent =
  `CENTER_OVERLAP:${CENTER_OVERLAP.toFixed(1)} EDGE_PADDING:${EDGE_PADDING.toFixed(1)} STAGGER_X:${STAGGER_X.toFixed(1)} SPINE_SHIFT:${SPINE_SHIFT.toFixed(1)}
NUM_CARDS:${NUM_CARDS} ALPHA:${ALPHA.toFixed(2)} DEPTH_RANGE:${DEPTH_RANGE.toFixed(2)} VIDEO_SCALE:${VIDEO_SCALE.toFixed(2)}
AUTO:${autoMode?"ON":"OFF"}`;
}

/* === HUD buttons === */
let hudVisible=true;
toggleBtn.addEventListener("click",toggleHUD);
toggleBtn.addEventListener("touchstart",toggleHUD,{passive:true});
resetBtn.addEventListener("click",resetHUD);
resetBtn.addEventListener("touchstart",resetHUD,{passive:true});
autoBtn.addEventListener("click",()=>{autoMode=!autoMode;
  autoBtn.style.background=autoMode?"rgba(150,200,255,.25)":"rgba(255,255,255,.08)";
});

function toggleHUD(){
  hudVisible = !hudVisible;

  if (hudVisible) {
    hud.classList.remove("hidden");
    hud.style.opacity = "1";
    hud.style.pointerEvents = "auto";
  } else {
    hud.classList.add("hidden");
    hud.style.opacity = "0.15";
    // ✅ Keep HUD button clickable when hidden
    document.getElementById("toggleHUD").style.pointerEvents = "auto";
  }


function resetHUD(){
  hud.style.transition="background 0.3s";
  hud.style.background="rgba(255,255,255,0.4)";
  setTimeout(()=>hud.style.background="var(--hud-bg)",250);

  CENTER_OVERLAP=0; EDGE_PADDING=300; NUM_CARDS=8; ALPHA=0.35;
  STAGGER_X=20; SPINE_SHIFT=26; DEPTH_RANGE=0.76; VIDEO_SCALE=1.5;

  [r1.value,r2.value,r3.value,r4.value,r5.value,r6.value,r7.value,r8.value] =
    [CENTER_OVERLAP,EDGE_PADDING,NUM_CARDS,ALPHA,STAGGER_X,SPINE_SHIFT,DEPTH_RANGE,VIDEO_SCALE];
  [o1.value,o2.value,o3.value,o4.value,o5.value,o6.value,o7.value,o8.value] =
    [CENTER_OVERLAP,EDGE_PADDING,NUM_CARDS,ALPHA,STAGGER_X,SPINE_SHIFT,DEPTH_RANGE,VIDEO_SCALE];

  initCards(currentVideo);
  flash.style.background="rgba(255,255,255,0.3)";
  setTimeout(()=>flash.style.background="rgba(255,255,255,0)",200);
}

/* === Render === */
function render(){
  const t=performance.now();
  if(autoMode){
    CENTER_OVERLAP=autoMod.CENTER_OVERLAP.base+Math.sin(t*autoMod.CENTER_OVERLAP.speed+autoMod.CENTER_OVERLAP.offset)*autoMod.CENTER_OVERLAP.range;
    EDGE_PADDING=autoMod.EDGE_PADDING.base+Math.sin(t*autoMod.EDGE_PADDING.speed+autoMod.EDGE_PADDING.offset)*autoMod.EDGE_PADDING.range;
    STAGGER_X=autoMod.STAGGER_X.base+Math.sin(t*autoMod.STAGGER_X.speed+autoMod.STAGGER_X.offset)*autoMod.STAGGER_X.range;
    SPINE_SHIFT=autoMod.SPINE_SHIFT.base+Math.sin(t*autoMod.SPINE_SHIFT.speed+autoMod.SPINE_SHIFT.offset)*autoMod.SPINE_SHIFT.range;
    initCards(currentVideo);
  }

  ctx.fillStyle="rgba(0,0,0,0.08)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  if(activeFade){
    activeFade.progress+=0.02;
    const p=Math.min(1,activeFade.progress);
    for(const c of cards){
      drawVideo(activeFade.oldVid,c,1-p);
      drawVideo(activeFade.newVid,c,p);
    }
    if(p>=1){currentVideo=activeFade.newVid;activeFade=null;}
  }else if(currentVideo){
    for(const c of cards)drawVideo(currentVideo,c,1);
  }
  updateHUD();
  requestAnimationFrame(render);
}

/* === Boot === */
(async()=>{
  const v=await loadRandomVideo();
  if(!v){console.warn("⚠️ No video found");return;}
  currentVideo=v;
  initCards(v);
  render();
})();
</script>
</body>
</html>
