<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>thumbnail_recursion4 — extreme smear</title>
<style>
  :root{
    --win-w: 260px;      /* window width  */
    --win-h: 160px;      /* window height */
    --win-opacity: 0.4;  /* translucent amount for DOM windows */
  }

  html,body{
    height:100%;
    margin:0;
    overflow:hidden;
    background:#000; /* black background for luminous trails */
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    cursor: default;
  }

  /* Feedback canvas behind everything */
  #feedbackCanvas{
    position:fixed;
    inset:0;
    z-index:0;
    display:block;
  }

  /* Container that holds all floating windows */
  .window-layer{
    position:fixed;
    inset:0;
    z-index:1;
    pointer-events:none; /* let each card manage its own events */
  }

  /* Floating “window” cards */
  .thumb-window{
    position:absolute;
    width:var(--win-w);
    height:var(--win-h);
    opacity:var(--win-opacity);
    border-radius:10px;
    overflow:hidden;                /* borderless; image clipped by rounded rect */
    pointer-events:auto;            /* re-enable on the element */
    user-select:none;
    backdrop-filter: blur(6px);     /* gentle frosted vibe while overlapping */
    -webkit-backdrop-filter: blur(6px);
    transform: translate3d(0,0,0);  /* promote to its own layer */
  }

  .thumb-window img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
    pointer-events:none;
  }

  /* Optional: subtle glow when grabbed */
  .thumb-window.dragging{
    box-shadow: 0 0 40px rgba(255,255,255,0.15);
  }

  /* Tiny, always-on hint text (can remove) */
  .hud{
    position:fixed;
    left:10px; bottom:10px;
    color:#9aa;
    font-size:12px;
    opacity:0.7;
    z-index:2;
    mix-blend-mode:screen;
  }
</style>
</head>
<body>
  <canvas id="feedbackCanvas"></canvas>
  <div class="window-layer" id="layer"></div>
  <div class="hud">drag windows • trails = ON • mode: additive/lighter</div>

<script>
(function(){
  // ===============================
  // CONFIG "KNOBS" — tweak live
  // ===============================
  const NUM_WINDOWS          = 6;
  const MAGNET_CENTER_BIAS   = 0.015;   // pull toward vertical spine (higher = stronger)
  const EDGE_BOUNCE_DAMPING  = 0.8;     // velocity retained on bounce (0-1)
  const MAX_SPEED            = 1.2;     // px/frame clamp
  const JITTER               = 0.02;    // random walk each frame
  const DRAG_INERTIA         = 0.12;    // how much mouse movement turns into velocity
  const CANVAS_FADE_ALPHA    = 0.08;    // frame-to-frame fade (lower = longer smear)
  const CANVAS_IMG_ALPHA     = 0.28;    // how bright each ghost stamp is
  const CANVAS_SCALE         = 1.0;     // render image to canvas at 1.0x DOM size
  const CANVAS_COMPOSITE     = 'lighter'; // additive glow on black

  // ===============================
  // IMAGE SOURCING (RSS hook)
  // ===============================
  // Replace this with your RSS-title → URL resolver when you plug the feed back in.
  function getImageUrlFromTitle(title){
    // EXAMPLE mapping by keyword; customize as you wish:
    const lower = String(title||'').toLowerCase();
    // Put some of your known thumbnail filenames here or return a deterministic URL
    if (lower.includes('cat'))   return 'https://images.unsplash.com/photo-1518791841217-8f162f1e1131?q=80&w=1200&auto=format&fit=crop';
    if (lower.includes('city'))  return 'https://images.unsplash.com/photo-1467269204594-9661b134dd2b?q=80&w=1200&auto=format&fit=crop';
    if (lower.includes('sea'))   return 'https://images.unsplash.com/photo-1507525428034-b723cf961d3e?q=80&w=1200&auto=format&fit=crop';
    if (lower.includes('fire'))  return 'https://images.unsplash.com/photo-1509223197845-458d87318791?q=80&w=1200&auto=format&fit=crop';
    if (lower.includes('forest'))return 'https://images.unsplash.com/photo-1501785888041-af3ef285b470?q=80&w=1200&auto=format&fit=crop';
    // Fallback random aesthetic:
    const pool = [
      'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?q=80&w=1200&auto=format&fit=crop',
      'https://images.unsplash.com/photo-1519681393784-d120267933ba?q=80&w=1200&auto=format&fit=crop',
      'https://images.unsplash.com/photo-1517302222118-cc6c3f0f0b43?q=80&w=1200&auto=format&fit=crop',
      'https://images.unsplash.com/photo-1526318472351-c75fcf070305?q=80&w=1200&auto=format&fit=crop',
      'https://images.unsplash.com/photo-1517694712202-14dd9538aa97?q=80&w=1200&auto=format&fit=crop',
      'https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?q=80&w=1200&auto=format&fit=crop'
    ];
    return pool[Math.floor(Math.random()*pool.length)];
  }

  // Placeholder titles (swap these with real RSS item titles)
  const rssTitles = [
    'City Light Reflections',
    'Forest Walk',
    'Sea Dream',
    'Cat’s Eye',
    'Fire Vector',
    'Night Signal'
  ];

  // ===============================
  // DOM & CANVAS SETUP
  // ===============================
  const canvas = document.getElementById('feedbackCanvas');
  const ctx    = canvas.getContext('2d', { alpha: true });
  const layer  = document.getElementById('layer');

  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap DPR for perf
  function resizeCanvas(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.width  = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width  = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // ===============================
  // CREATE WINDOWS
  // ===============================
  const windows = [];

  function makeWindow(imgUrl, ix){
    const el = document.createElement('div');
    el.className = 'thumb-window';
    el.style.left = (Math.random() * (window.innerWidth - 320) + 30) + 'px';
    el.style.top  = (Math.random() * (window.innerHeight - 220) + 30) + 'px';

    const img = document.createElement('img');
    img.decoding = 'async';
    img.loading  = 'lazy';
    img.crossOrigin = 'anonymous'; // helps canvas draw if CORS allows
    img.src = imgUrl;

    el.appendChild(img);
    layer.appendChild(el);

    // Keep a parallel Image object for guaranteed canvas draw timing.
    const imgForCanvas = new Image();
    imgForCanvas.crossOrigin = 'anonymous';
    imgForCanvas.src = imgUrl;

    // State
    const rect = el.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    const state = {
      el,
      imgEl: img,
      imgCanvas: imgForCanvas,
      x: rect.left,
      y: rect.top,
      w, h,
      vx: (Math.random() - 0.5) * 0.8,
      vy: (Math.random() - 0.5) * 0.8,
      dragging: false,
      dragOffX: 0,
      dragOffY: 0,
      lastMouseX: 0,
      lastMouseY: 0
    };

    // Drag handlers (mouse + touch)
    const onPointerDown = (clientX, clientY) => {
      state.dragging = true;
      el.classList.add('dragging');
      state.dragOffX = clientX - state.x;
      state.dragOffY = clientY - state.y;
      state.lastMouseX = clientX;
      state.lastMouseY = clientY;
    };
    const onPointerMove = (clientX, clientY) => {
      if (!state.dragging) return;
      state.x = clientX - state.dragOffX;
      state.y = clientY - state.dragOffY;
      // derive velocity from pointer deltas for nice “throw”
      const dx = clientX - state.lastMouseX;
      const dy = clientY - state.lastMouseY;
      state.vx = (state.vx * (1-DRAG_INERTIA)) + (dx * DRAG_INERTIA);
      state.vy = (state.vy * (1-DRAG_INERTIA)) + (dy * DRAG_INERTIA);
      state.lastMouseX = clientX;
      state.lastMouseY = clientY;
    };
    const onPointerUp = () => {
      state.dragging = false;
      el.classList.remove('dragging');
    };

    // Mouse
    el.addEventListener('mousedown', (e)=>{
      e.preventDefault();
      onPointerDown(e.clientX, e.clientY);
      // bring to front
      layer.appendChild(el);
    });
    window.addEventListener('mousemove', (e)=>{
      onPointerMove(e.clientX, e.clientY);
    });
    window.addEventListener('mouseup', onPointerUp);

    // Touch
    el.addEventListener('touchstart', (e)=>{
      const t = e.touches[0];
      onPointerDown(t.clientX, t.clientY);
      layer.appendChild(el);
    }, {passive:false});
    window.addEventListener('touchmove', (e)=>{
      const t = e.touches[0];
      onPointerMove(t.clientX, t.clientY);
    }, {passive:false});
    window.addEventListener('touchend', onPointerUp);

    windows.push(state);
  }

  // Build windows from titles (simulate RSS)
  for (let i=0; i<NUM_WINDOWS; i++){
    const title = rssTitles[i % rssTitles.length];
    const url   = getImageUrlFromTitle(title);
    makeWindow(url, i);
  }

  // ===============================
  // ANIMATION LOOP (DOM + CANVAS)
  // ===============================
  function clampMag(v, max){
    const m = Math.hypot(v.vx, v.vy);
    if (m > max){
      const s = max / (m || 1e-6);
      v.vx *= s; v.vy *= s;
    }
  }

  function step(){
    const W = window.innerWidth;
    const H = window.innerHeight;
    const centerX = W * 0.5;

    // Fade the canvas slightly (persistent afterimages)
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = `rgba(0,0,0,${CANVAS_FADE_ALPHA})`;
    ctx.fillRect(0,0,W,H);

    // Draw trails in additive mode for glow
    ctx.globalCompositeOperation = CANVAS_COMPOSITE;

    // Physics + DOM position + Canvas paint
    for (const win of windows){
      if (!win.dragging){
        // random jitter (keeps things “alive”)
        win.vx += (Math.random() - 0.5) * JITTER;
        win.vy += (Math.random() - 0.5) * JITTER;

        // magnetic pull toward vertical spine (x only)
        const dxToSpine = (centerX - (win.x + win.w*0.5));
        win.vx += dxToSpine * MAGNET_CENTER_BIAS * 0.016; // scaled for 60fps-ish

        // Clamp speed
        clampMag(win, MAX_SPEED);

        // Update position
        win.x += win.vx;
        win.y += win.vy;

        // Constrained “tighter” than 6cards: smaller roam area margin
        const margin = 10; // keeps within viewport
        if (win.x < margin){ win.x = margin; win.vx = -win.vx * EDGE_BOUNCE_DAMPING; }
        if (win.y < margin){ win.y = margin; win.vy = -win.vy * EDGE_BOUNCE_DAMPING; }
        if (win.x + win.w > W - margin){ win.x = W - margin - win.w; win.vx = -win.vx * EDGE_BOUNCE_DAMPING; }
        if (win.y + win.h > H - margin){ win.y = H - margin - win.h; win.vy = -win.vy * EDGE_BOUNCE_DAMPING; }
      }

      // Position DOM element
      win.el.style.transform = `translate3d(${win.x}px, ${win.y}px, 0)`;

      // Smear/ghost the image onto the canvas
      const img = win.imgCanvas;
      if (img && img.complete){
        const drawW = win.w * CANVAS_SCALE;
        const drawH = win.h * CANVAS_SCALE;
        const drawX = win.x + (win.w - drawW)/2;
        const drawY = win.y + (win.h - drawH)/2;

        // main stamp
        ctx.globalAlpha = CANVAS_IMG_ALPHA;
        ctx.drawImage(img, drawX, drawY, drawW, drawH);

        // a second, slightly offset + scaled stamp deepens the smear
        ctx.globalAlpha = CANVAS_IMG_ALPHA * 0.55;
        ctx.drawImage(img, drawX + 6, drawY + 4, drawW*0.98, drawH*0.98);
      }
    }

    // restore defaults
    ctx.globalAlpha = 1.0;
    ctx.globalCompositeOperation = 'source-over';

    requestAnimationFrame(step);
  }

  // Prime the canvas to solid black (so first fade doesn’t “flash”)
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  requestAnimationFrame(step);

  // ===============================
  // PUBLIC HOOKS (plug RSS later)
  // ===============================
  // Call this later with your feed titles to re-populate:
  // applyRssTitles(['Title A','Title B',...])
  window.applyRssTitles = function(titles){
    // remove existing
    for (const w of windows){
      w.el.remove();
    }
    windows.length = 0;

    const n = Math.max(1, titles.length);
    for (let i=0;i<NUM_WINDOWS;i++){
      const title = titles[i % n];
      const url   = getImageUrlFromTitle(title);
      makeWindow(url, i);
    }
  };
})();
</script>
</body>
</html>
