<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>a_SingleSharedVideoSplitIntoPanels — HUD</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>

<style>

  :root{
    --hud-bg: rgba(10,10,10,.7);
    --hud-fg: #e6f3ff;
    --hud-ac: #98d5ff;
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{display:block;touch-action:none}
  /* Minimal fixed HUD (top-left) */
  .hud{
    position:fixed;top:10px;left:10px;z-index:10;
    padding:10px 12px;border-radius:8px;
    background:var(--hud-bg);color:var(--hud-fg);
    font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    user-select:none;
    backdrop-filter: blur(6px);
  }
  .hud h1{
    margin:0 0 8px;font-size:12px;font-weight:600;letter-spacing:.02em;color:var(--hud-ac)
  }
  .row{display:grid;grid-template-columns:110px 1fr 46px;gap:8px;align-items:center;margin:6px 0}
  .row label{white-space:nowrap;opacity:.9}
  .row input[type="range"]{width:220px}
  .row output{justify-self:end;min-width:46px;text-align:right;opacity:.95}
  .tiny{font-size:11px;opacity:.75;margin-top:6px}
  .row select, .row input[type="number"]{
    background:rgba(255,255,255,.06); color:var(--hud-fg); border:1px solid rgba(255,255,255,.12);
    border-radius:6px; padding:4px 6px; width:80px;
  }
  .btnline{display:flex;gap:8px;margin-top:6px}
  .btn{
    background:rgba(255,255,255,.08); color:var(--hud-fg); border:1px solid rgba(255,255,255,.16);
    padding:6px 10px; border-radius:6px; cursor:pointer; font-size:12px;
  }
  .btn:hover{background:rgba(255,255,255,.12)}

  
</style>
</head>
<body>

<canvas id="c"></canvas>

<!-- Minimal fixed HUD -->
<div class="hud" id="hud">
  <h1>Glass Panels — Controls</h1>

  <div class="row">
    <label for="num">NUM_CARDS</label>
    <input id="num" type="range" min="4" max="16" step="2" value="8">
    <output id="numOut">8</output>
  </div>

  <div class="row">
    <label for="overlap">CENTER_OVERLAP</label>
    <input id="overlap" type="range" min="0" max="480" step="2" value="220">
    <output id="overlapOut">220</output>
  </div>

  <div class="row">
    <label for="edge">EDGE_PADDING</label>
    <input id="edge" type="range" min="0" max="160" step="2" value="30">
    <output id="edgeOut">30</output>
  </div>

  <div class="row">
    <label for="sx">STAGGER_X</label>
    <input id="sx" type="range" min="0" max="120" step="1" value="8">
    <output id="sxOut">8</output>
  </div>

  <div class="row">
    <label for="sy">STAGGER_Y</label>
    <input id="sy" type="range" min="0" max="120" step="1" value="6">
    <output id="syOut">6</output>
  </div>

  <div class="row">
    <label for="ab">ALPHA_BASE</label>
    <input id="ab" type="range" min="0" max="1" step="0.01" value="0.32">
    <output id="abOut">0.32</output>
  </div>

  <div class="row">
    <label for="ar">DEPTH_RANGE</label>
    <input id="ar" type="range" min="0" max="1" step="0.01" value="0.18">
    <output id="arOut">0.18</output>
  </div>

  <div class="btnline">
    <button class="btn" id="resetBtn">Reset</button>
  </div>

  <div class="tiny" id="readout"></div>
</div>

<script>
/* =============== Canvas ================= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener('resize', resize);
resize();

/* =============== Params (live) ================= */
const PARAM = {
  NUM_CARDS:   8,
  CENTER_OVERLAP: 220,
  EDGE_PADDING:   30,
  STAGGER_X:   8,
  STAGGER_Y:   6,
  ALPHA_BASE:  0.32,
  DEPTH_RANGE: 0.18
};

/* HUD wires: continuous updates + numeric outputs */
const ui = {
  num: document.getElementById('num'),
  overlap: document.getElementById('overlap'),
  edge: document.getElementById('edge'),
  sx: document.getElementById('sx'),
  sy: document.getElementById('sy'),
  ab: document.getElementById('ab'),
  ar: document.getElementById('ar'),
  numOut: document.getElementById('numOut'),
  overlapOut: document.getElementById('overlapOut'),
  edgeOut: document.getElementById('edgeOut'),
  sxOut: document.getElementById('sxOut'),
  syOut: document.getElementById('syOut'),
  abOut: document.getElementById('abOut'),
  arOut: document.getElementById('arOut'),
  readout: document.getElementById('readout'),
  resetBtn: document.getElementById('resetBtn'),
};

function syncHUD(){
  ui.num.value = PARAM.NUM_CARDS; ui.numOut.textContent = PARAM.NUM_CARDS;
  ui.overlap.value = PARAM.CENTER_OVERLAP; ui.overlapOut.textContent = PARAM.CENTER_OVERLAP;
  ui.edge.value = PARAM.EDGE_PADDING; ui.edgeOut.textContent = PARAM.EDGE_PADDING;
  ui.sx.value = PARAM.STAGGER_X; ui.sxOut.textContent = PARAM.STAGGER_X;
  ui.sy.value = PARAM.STAGGER_Y; ui.syOut.textContent = PARAM.STAGGER_Y;
  ui.ab.value = PARAM.ALPHA_BASE; ui.abOut.textContent = PARAM.ALPHA_BASE.toFixed(2);
  ui.ar.value = PARAM.DEPTH_RANGE; ui.arOut.textContent = PARAM.DEPTH_RANGE.toFixed(2);
  ui.readout.textContent =
    `NUM:${PARAM.NUM_CARDS} | OVERLAP:${PARAM.CENTER_OVERLAP} | EDGE:${PARAM.EDGE_PADDING} | `+
    `SX:${PARAM.STAGGER_X} | SY:${PARAM.STAGGER_Y} | α:${PARAM.ALPHA_BASE.toFixed(2)}±${PARAM.DEPTH_RANGE.toFixed(2)}`;
}
syncHUD();

function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
function lerp(a,b,t){ return a+(b-a)*t; }

/* =============== Media load (single shared video) ================= */
async function loadOneVideo(){
  const MEDIA_API = "https://art.jeffgompertz.site/wp-json/wp/v2/media?per_page=50";
  try{
    const r = await fetch(MEDIA_API);
    const d = await r.json();
    const filtered = d.filter(m => (m.mime_type && m.mime_type.startsWith('video/')) ||
                                   (m.source_url && /\.mp4(\?.*)?$/i.test(m.source_url)));
    if(!filtered.length) throw new Error('No videos in WP JSON');
    const m = filtered[Math.floor(Math.random()*filtered.length)];
    const v = document.createElement('video');
    v.src = m.source_url;
    v.loop = true; v.muted = true; v.playsInline = true; v.preload = 'auto';
    v.style.display = 'none';
    document.body.appendChild(v);
    await new Promise(res=>{
      const ok = ()=>res();
      v.oncanplay = ok; v.onerror = ok; setTimeout(ok,1500);
    });
    v.play().catch(()=>{});
    return v;
  }catch(e){
    console.warn('Media error, using fallback', e);
    const v = document.createElement('video');
    v.src = 'https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4';
    v.loop = true; v.muted = true; v.playsInline = true; v.preload='auto';
    v.style.display='none'; document.body.appendChild(v);
    await new Promise(res=>{v.oncanplay=res; setTimeout(res,1200);});
    v.play().catch(()=>{});
    return v;
  }
}

/* iOS gesture unlock */
function startVideos(){ document.querySelectorAll('video').forEach(v=>v.play().catch(()=>{})); }
addEventListener('touchstart', startVideos, { once:true });
addEventListener('click', startVideos, { once:true });

/* =============== Layout: unified spine alignment =================
   Goal: both left+right stacks converge to a shared central X so the image feels continuous.
   - Panels are wide (W/2 + CENTER_OVERLAP) to guarantee overlap at the spine
   - Each side interpolates from the outer edge (EDGE_PADDING) toward the shared center target
   - Small STAGGER_X/STAGGER_Y add organic drift (set to 0 for perfect alignment)
=================================================================== */
let cards = [];     // {x,y,w,h,alpha}
let currentVideo = null;

function rebuildLayout(){
  const W = canvas.width, H = canvas.height;
  const N = Math.max(4, (PARAM.NUM_CARDS|0));            // enforce min
  const perSide = Math.floor(N/2);
  const w = Math.max(W/2 + PARAM.CENTER_OVERLAP, 10);    // wide for overlap
  const h = H;                                           // full height

  // Shared center target for both sides
  const centerX = (W/2 - w/2);                           // exact spine alignment

  // Outer edges the furthest panels should approach
  const leftEdgeX  = PARAM.EDGE_PADDING;
  const rightEdgeX = W - PARAM.EDGE_PADDING - w;

  cards = [];
  for(let i=0; i<perSide; i++){
    const t = (perSide===1)? 1 : i/(perSide-1);          // 0 (edge) → 1 (center)
    const jitterX = (Math.random()-0.5)*PARAM.STAGGER_X;
    const jitterY = (Math.random()-0.5)*PARAM.STAGGER_Y;
    const alphaL  = clamp(PARAM.ALPHA_BASE + (Math.random()-0.5)*PARAM.DEPTH_RANGE, 0, 1);
    const alphaR  = clamp(PARAM.ALPHA_BASE + (Math.random()-0.5)*PARAM.DEPTH_RANGE, 0, 1);

    // Left panel: move from left edge toward shared center
    const xL = lerp(leftEdgeX, centerX, t) + jitterX;
    // Right panel: move from right edge toward shared center
    const xR = lerp(rightEdgeX, centerX, t) + jitterX;

    cards.push({ x:xL, y:jitterY, w, h, alpha:alphaL });
    cards.push({ x:xR, y:jitterY, w, h, alpha:alphaR });
  }
  syncHUD();
}

/* =============== Drawing helpers =============== */
function drawVideoCover(v, x,y,w,h, a=1){
  if(!v || v.readyState < 2) return;
  const iw = v.videoWidth || v.width, ih = v.videoHeight || v.height;
  if(!iw || !ih) return;
  const r  = Math.max(w/iw, h/ih);
  const nw = iw*r, nh = ih*r;
  const ox = x + (w-nw)/2, oy = y + (h-nh)/2;
  ctx.globalAlpha = a;
  ctx.drawImage(v, ox, oy, nw, nh);
  ctx.globalAlpha = 1;
}

/* =============== Animate =============== */
function render(){
  // gentle persistence
  ctx.fillStyle = 'rgba(0,0,0,0.05)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw from back to front (simple: insertion order is fine)
  if(currentVideo){
    for(const c of cards){
      drawVideoCover(currentVideo, c.x, c.y, c.w, c.h, c.alpha);
    }
  }
  requestAnimationFrame(render);
}

/* =============== HUD interactions =============== */
function reflowFromUI(){
  PARAM.NUM_CARDS     = parseInt(ui.num.value,10);
  PARAM.CENTER_OVERLAP= parseInt(ui.overlap.value,10);
  PARAM.EDGE_PADDING  = parseInt(ui.edge.value,10);
  PARAM.STAGGER_X     = parseInt(ui.sx.value,10);
  PARAM.STAGGER_Y     = parseInt(ui.sy.value,10);
  PARAM.ALPHA_BASE    = parseFloat(ui.ab.value);
  PARAM.DEPTH_RANGE   = parseFloat(ui.ar.value);
  syncHUD();
  rebuildLayout();
}

['input','change'].forEach(ev=>{
  ui.num.addEventListener(ev, reflowFromUI);
  ui.overlap.addEventListener(ev, reflowFromUI);
  ui.edge.addEventListener(ev, reflowFromUI);
  ui.sx.addEventListener(ev, reflowFromUI);
  ui.sy.addEventListener(ev, reflowFromUI);
  ui.ab.addEventListener(ev, reflowFromUI);
  ui.ar.addEventListener(ev, reflowFromUI);
});

ui.resetBtn.addEventListener('click', ()=>{
  Object.assign(PARAM, {
    NUM_CARDS:8, CENTER_OVERLAP:220, EDGE_PADDING:30,
    STAGGER_X:8, STAGGER_Y:6, ALPHA_BASE:0.32, DEPTH_RANGE:0.18
  });
  syncHUD();
  rebuildLayout();
});

/* =============== Boot =============== */
(async ()=>{
  currentVideo = await loadOneVideo();
  rebuildLayout();
  render();
})();
</script>
</body>
</html>
