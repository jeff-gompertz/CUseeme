<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Baseline Touch â€“ Thumbnail Feedback Test</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }

  .thumb-window {
    position: absolute;
    width: 260px;
    height: 160px;
    overflow: hidden;
    border: none;
    box-shadow: 0 0 25px rgba(0,0,0,0.4);
    background: rgba(255,255,255,0.05);
    opacity: 0.85;
    touch-action: none;
    -webkit-user-select: none;
            user-select: none;
    -webkit-touch-callout: none;
    cursor: grab;
  }

  .thumb-window img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    pointer-events: none;
  }

  .thumb-window:active {
    cursor: grabbing;
  }

  canvas#feedback {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
</style>
</head>
<body>

<canvas id="feedback"></canvas>
<div id="windows"></div>

<script>
const container = document.getElementById("windows");
const canvas = document.getElementById("feedback");
const ctx = canvas.getContext("2d");
let W = window.innerWidth, H = window.innerHeight;
canvas.width = W; 
canvas.height = H;

window.addEventListener("resize", () => {
  W = window.innerWidth; 
  H = window.innerHeight;
  canvas.width = W; 
  canvas.height = H;
});

const feedUrl =
  "https://www.youtube.com/feeds/videos.xml?channel_id=UCREEmHdAYvlboosrKCHe4UA";

let images = [];
let thumbs = [];
const MAX_THUMBS = 5;

fetch("https://api.rss2json.com/v1/api.json?rss_url=" + encodeURIComponent(feedUrl))
  .then(res => res.json())
  .then(data => {
    const items = (data && data.items) ? data.items.slice(0, MAX_THUMBS) : [];
    if (!items.length) throw new Error("No RSS items");

    images = items.map(item => {
      const vid = (item.guid || "").split(":").pop();
      const src = item.thumbnail || `https://i.ytimg.com/vi/${vid}/hqdefault.jpg`;

      const im = new Image();
      im.crossOrigin = "anonymous";
      im.src = src;
      return im;
    });

    images.forEach((im, i) => {
      const div = document.createElement("div");
      div.className = "thumb-window";
      div.style.left = (50 + i * 40) + "px";
      div.style.top  = (50 + i * 50) + "px";
      div.innerHTML = `<img src="${im.src}" alt="thumb">`;
      container.appendChild(div);
      thumbs.push({el: div, img: im, vx: (Math.random()*2-1)*0.4, vy: (Math.random()*2-1)*0.4});
      makeDraggable(div);
    });

    requestAnimationFrame(drawFeedback);
  })
  .catch(err => console.error("Feed error:", err));

function makeDraggable(el) {
  let dragging = false, offsetX = 0, offsetY = 0;

  el.addEventListener("pointerdown", e => {
    dragging = true;
    el.setPointerCapture(e.pointerId);
    offsetX = e.clientX - el.offsetLeft;
    offsetY = e.clientY - el.offsetTop;
    el.style.cursor = "grabbing";
  });

  el.addEventListener("pointermove", e => {
    if (!dragging) return;
    let x = e.clientX - offsetX;
    let y = e.clientY - offsetY;
    x = Math.max(0, Math.min(W - el.offsetWidth, x));
    y = Math.max(0, Math.min(H - el.offsetHeight, y));
    el.style.left = x + "px";
    el.style.top  = y + "px";
  });

  el.addEventListener("pointerup", e => {
    dragging = false;
    el.style.cursor = "grab";
    try { el.releasePointerCapture(e.pointerId); } catch {}
  });
  el.addEventListener("pointercancel", () => { dragging = false; });
}

function drawFeedback() {
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.fillRect(0, 0, W, H);

  thumbs.forEach(t => {
    if (t.img.complete) {
      const x = parseFloat(t.el.style.left);
      const y = parseFloat(t.el.style.top);
      ctx.drawImage(t.img, x, y, t.el.offsetWidth, t.el.offsetHeight);
    }
  });

  requestAnimationFrame(drawFeedback);
}
</script>
</body>
</html>
