<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Database Recursion — Text Input Stage 1</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    height: 100%;
    font-family: "Helvetica Neue", Arial, sans-serif;
  }

  /* === VISUAL FIELD (recursion canvas) === */
  canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: -2;
  }

  /* === TEXT FEED LAYER === */
  #text-feed {
    position: fixed;
    bottom: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    overflow: hidden;
    z-index: -1; /* sits above canvas but below future windows */
    color: white;
  }

  #feed-content {
    text-align: center;
    width: 80%;
    font-size: 1.5rem;
    line-height: 2rem;
  }

  .headline {
    margin: 1rem 0;
  }
</style>
</head>
<body>

<canvas id="trail"></canvas>
<div id="text-feed"><div id="feed-content"></div></div>

<script>
/* ==========================================================
   VISUAL RECURSION CORE
   (from database_recursion_visual.html baseline)
========================================================== */
const canvas = document.getElementById("trail");
const ctx = canvas.getContext("2d");
let W = innerWidth, H = innerHeight;
canvas.width = W; canvas.height = H;

window.addEventListener("resize", () => {
  W = innerWidth; H = innerHeight;
  canvas.width = W; canvas.height = H;
});

let t = 0;
function draw() {
  t += 0.01;
  // draw previous frame for feedback
  ctx.globalAlpha = 0.94;
  ctx.drawImage(canvas, 0, 0, W, H);
  ctx.globalAlpha = 1.0;

  // subtle harmonic color modulation
  const hue = 200 + 60 * Math.sin(t * 0.5);
  ctx.fillStyle = `hsla(${hue}, 80%, 55%, 0.1)`;
  ctx.fillRect(0, 0, W, H);

  // gentle noise dots (optional, just to see motion)
  for (let i = 0; i < 30; i++) {
    const x = Math.random() * W;
    const y = Math.random() * H;
    const s = 1 + Math.sin(t + x * 0.001) * 2;
    ctx.fillStyle = `hsla(${hue}, 90%, 70%, 0.15)`;
    ctx.fillRect(x, y, s, s);
  }

  requestAnimationFrame(draw);
}
draw();

/* ==========================================================
   BBC RSS TEXT FEED (clean film-title scroll)
========================================================== */
const feedURL = "https://feeds.bbci.co.uk/news/rss.xml";
const proxy = "https://api.allorigins.win/get?url=" + encodeURIComponent(feedURL);

fetch(proxy)
  .then(r => r.ok ? r.json() : Promise.reject(r))
  .then(data => {
    const parser = new DOMParser();
    const xml = parser.parseFromString(data.contents, "text/xml");
    const titles = [...xml.querySelectorAll("item > title")].map(t => t.textContent);
    buildFeed(titles);
  })
  .catch(err => {
    console.warn("Feed unavailable, using fallback", err);
    buildFeed([
      "Fallback headline — data stream offline",
      "BBC feed not reachable — autonomous mode",
      "Text input layer waiting for new signals"
    ]);
  });

function buildFeed(lines) {
  const feed = document.getElementById("feed-content");
  lines.forEach(line => {
    const div = document.createElement("div");
    div.className = "headline";
    div.textContent = line;
    feed.appendChild(div);
  });
  startScroll();
}

function startScroll() {
  const content = document.getElementById("feed-content");
  let y = window.innerHeight;
  function animate() {
    y -= 0.5; // scroll speed
    content.style.transform = `translateY(${y}px)`;
    if (y + content.offsetHeight > 0) {
      requestAnimationFrame(animate);
    } else {
      y = window.innerHeight; // loop
      requestAnimationFrame(animate);
    }
  }
  animate();
}
</script>

</body>
</html>
