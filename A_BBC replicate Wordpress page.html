<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BBC → Prompt → SDXL (One Headline at a Time)</title>

<style>
  :root{--acid:#e9ff32;--bg:#000;--glass:rgba(0,0,0,.72);--soft:rgba(255,255,255,.72);}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Arial,Helvetica,sans-serif;}
  #stage{position:relative;height:100vh;overflow:hidden;background:#000;}

  /* Fullscreen image result (dramatic) */
  #imgOut{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    opacity:.92;
    filter:contrast(1.02) saturate(1.08);
    display:none;
  }
  /* Subtle dark veil so white text stays readable */
  #veil{
    position:absolute; inset:0;
    background:radial-gradient(circle at 50% 35%, rgba(0,0,0,.25), rgba(0,0,0,.75) 70%, rgba(0,0,0,.85));
    pointer-events:none;
  }

  /* Your ecran treatment (big, centered, narrow) */
  #ecran{
    position:relative;
    height:100vh;
    overflow:hidden;
    width:80%;
    margin:0 auto;
    text-align:center;
    color:white;
    opacity:0.92;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  #ecran-inner{
    height:100%;
    width:100%;
    overflow-y:scroll;
    scrollbar-width:none;
    -ms-overflow-style:none;
    pointer-events:none !important;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:3vh 0;
  }
  #ecran-inner::-webkit-scrollbar{display:none;}
  #headline{
    margin:0;
    font-size:11rem;     /* keep your dramatic scale */
    font-weight:800;
    line-height:1.05;
    letter-spacing:-0.02em;
    word-break:break-word;
  }
  @media (max-width:900px){
    #headline{font-size:6.8rem;}
    #ecran{width:92%;}
  }
  @media (max-width:520px){
    #headline{font-size:4.2rem;}
  }

  /* Prompt output box (white box you saw, but styled as “artifact”) */
  #promptBox{
    position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
    width:min(920px, calc(100% - 28px));
    background:rgba(255,255,255,.92);
    color:#000;
    border-radius:14px;
    padding:12px 14px;
    font-size:16px;
    line-height:1.25;
    box-shadow:0 18px 60px rgba(0,0,0,.55);
  }
  #promptBox b{color:#000;}
  #promptText{margin-top:6px; font-weight:700;}
  #statusRow{
    margin-top:10px;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    font-size:12px; color:rgba(0,0,0,.72);
  }
  .pill{
    border:1px solid rgba(0,0,0,.16);
    padding:6px 10px;
    border-radius:999px;
    background:rgba(255,255,255,.7);
  }
  .btn{
    cursor:pointer;
    border-radius:999px;
    border:1px solid rgba(0,0,0,.22);
    padding:8px 12px;
    background:#fff;
    font-weight:900;
    letter-spacing:.08em;
    text-transform:uppercase;
    font-size:11px;
  }
  .btn:disabled{opacity:.45;cursor:default;}
  #tinyLog{
    margin-top:10px;
    max-height:96px;
    overflow:auto;
    font:12px/1.35 ui-monospace, Menlo, Monaco, Consolas, monospace;
    color:rgba(0,0,0,.65);
    background:rgba(0,0,0,.04);
    border-radius:10px;
    padding:8px 10px;
    white-space:pre-wrap;
  }
</style>
</head>

<body>
<div id="stage">
  <img id="imgOut" alt="SDXL output" />
  <div id="veil"></div>

  <div id="ecran">
    <div id="ecran-inner">
      <p id="headline">Loading BBC…</p>
    </div>
  </div>

  <div id="promptBox">
    <div><b>Derived prompt (one headline)</b></div>
    <div id="promptText">—</div>

    <div id="statusRow">
      <span class="pill">Headline <b id="hIndex">0</b>/<b id="hTotal">0</b></span>
      <span class="pill">Mode: <b>BBC → Prompt → SDXL</b></span>
      <button class="btn" id="btnNext">Next Headline</button>
      <button class="btn" id="btnRun" disabled>Generate Image</button>
      <button class="btn" id="btnAuto">Auto: ON</button>
    </div>

    <div id="tinyLog"></div>
  </div>
</div>

<script>
(() => {
  const API_BASE = "https://art.jeffgompertz.site";

  // Existing endpoints you already have
  const EP_BBC     = new URL("/wp-json/ganemulator/v1/bbc", API_BASE).toString();
  const EP_NEWS    = new URL("/wp-json/ganemulator/v1/news_prompt", API_BASE).toString();
  const EP_IMG2IMG = new URL("/wp-json/ganemulator/v1/img2img", API_BASE).toString();
  const EP_POLL    = new URL("/wp-json/ganemulator/v1/poll", API_BASE).toString();

  const $ = (id)=>document.getElementById(id);
  const headlineEl = $("headline");
  const promptEl   = $("promptText");
  const hIndexEl   = $("hIndex");
  const hTotalEl   = $("hTotal");
  const logEl      = $("tinyLog");
  const imgOut     = $("imgOut");

  const btnNext = $("btnNext");
  const btnRun  = $("btnRun");
  const btnAuto = $("btnAuto");

  // ===== tiny logger =====
  const L = [];
  function log(line){
    const ts = new Date().toISOString().slice(11,19);
    L.push(`[${ts}] ${line}`);
    while(L.length>60) L.shift();
    logEl.textContent = L.join("\n");
    logEl.scrollTop = logEl.scrollHeight;
    console.log(line);
  }

  // ===== BBC state =====
  let items = [];
  let idx = 0;
  let autoOn = true;
  let autoTimer = null;

  // ===== prompt state =====
  let lastPrompt = "";
  let lastHeadlineText = "";

  // ===== image generation state =====
  let lastPredictionId = null;

  // ===== helpers =====
  async function getJSON(url){
    const r = await fetch(url, { cache: "no-store" });
    const j = await r.json();
    return j;
  }

  async function postJSON(url, obj){
    const r = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(obj)
    });
    const ct = (r.headers.get("content-type") || "").toLowerCase();
    const raw = await r.text();
    log(`POST ${new URL(url).pathname} → http ${r.status}`);
    return { r, ct, raw };
  }

  function headlineToText(it){
    const t = (it && it.title) ? it.title.trim() : "";
    const d = (it && it.desc)  ? it.desc.trim()  : "";
    // Keep it deliberate: one headline + (optional) one sentence of context.
    const one = d ? `${t}. ${d}` : t;
    return one.replace(/\s+/g, " ").trim();
  }

  // Create a “seed image” so SDXL img2img can run without user uploads.
  // This keeps the piece self-contained.
  function makeNoiseSeedDataURL(size=1024){
    const c = document.createElement("canvas");
    c.width = size; c.height = size;
    const ctx = c.getContext("2d");
    const img = ctx.createImageData(size, size);
    const data = img.data;

    // Grainy monochrome noise (fast enough for 1024 once per run)
    for (let i=0; i<data.length; i+=4){
      const v = (Math.random()*255)|0;
      data[i] = v; data[i+1] = v; data[i+2] = v; data[i+3] = 255;
    }
    ctx.putImageData(img, 0, 0);
    return c.toDataURL("image/jpeg", 0.92);
  }

  async function pollPrediction(id){
    for (let i=0;i<60;i++){
      await new Promise(r=>setTimeout(r, 1500));
      const { ct, raw } = await postJSON(EP_POLL, { id });
      if (!ct.includes("application/json")) return { ok:false, error:"bad_json_head" };
      const j = JSON.parse(raw);
      if (!j.ok) return { ok:false, error:j.error || "poll_failed" };
      const p = j.prediction;
      if (p && p.status) log(`status: ${p.status}`);
      if (p && p.status === "succeeded") return { ok:true, prediction:p };
      if (p && p.status === "failed") return { ok:false, error:"prediction_failed" };
    }
    return { ok:false, error:"poll_timeout" };
  }

  function setHeadline(i){
    if (!items.length) return;
    idx = (i + items.length) % items.length;
    const it = items[idx];
    const text = headlineToText(it);

    headlineEl.textContent = text || "—";
    hIndexEl.textContent = String(idx+1);
    hTotalEl.textContent = String(items.length);

    // keep a scrolling “ecran” motion (your original strategy)
    // we keep the inner div scroll, but the content is one big block,
    // so we simulate “motion” by nudging scrollTop.
    $("ecran-inner").scrollTop = 0;

    lastHeadlineText = text;
    btnRun.disabled = true;
    promptEl.textContent = "—";
    lastPrompt = "";
    log(`headline set: ${idx+1}/${items.length}`);
  }

  // ===== B + C core: one headline → prompt → SDXL =====
  async function derivePromptFromHeadline(){
    if (!lastHeadlineText) return;
    log("deriving prompt…");
    const payload = { text: lastHeadlineText };

    const { ct, raw } = await postJSON(EP_NEWS, payload);

    // Two possible server behaviors:
    // (1) returns a string directly
    // (2) returns a Replicate prediction id (then we poll /poll)
    let promptText = null;

    if (ct.includes("application/json")){
      const j = JSON.parse(raw);

      // case (1): server returns { ok:true, prompt:"..." } or { ok:true, text:"..." }
      if (j && j.ok && (typeof j.prompt === "string" || typeof j.text === "string")){
        promptText = (j.prompt || j.text).trim();
      }

      // case (2): server returns { ok:true, prediction:{ id:"..." } }
      if (!promptText && j && j.ok && j.prediction && j.prediction.id){
        const pid = j.prediction.id;
        log(`prompt prediction id: ${pid}`);
        const polled = await pollPrediction(pid);
        if (polled.ok){
          const out = polled.prediction.output;
          // many LLMs return string or array of strings
          if (typeof out === "string") promptText = out.trim();
          if (Array.isArray(out) && out.length) promptText = String(out[0]).trim();
        }
      }
    } else {
      // Some setups might return plain text
      promptText = String(raw || "").trim();
    }

    if (!promptText){
      promptEl.textContent = "Prompt failed (no text).";
      log("prompt failed: no text returned");
      return;
    }

    // normalize: remove surrounding quotes/labels if any
    promptText = promptText.replace(/^["'“”]+|["'“”]+$/g, "").trim();

    lastPrompt = promptText;
    promptEl.textContent = promptText;
    btnRun.disabled = false;
    log("prompt ready ✅");
  }

  async function generateImageFromPrompt(){
    if (!lastPrompt) return;
    btnRun.disabled = true;
    btnNext.disabled = true;

    log("building seed…");
    const seed = makeNoiseSeedDataURL(1024);

    log("sending to SDXL img2img…");
    const payload = {
      image: seed,
      prompt: lastPrompt,
      // use your intensity preset server-side; strength is optional.
      // If your PHP uses $body['strength'], keep it here:
      strength: 0.82
    };

    const { ct, raw } = await postJSON(EP_IMG2IMG, payload);
    if (!ct.includes("application/json")){
      log("img2img error: non-json");
      btnRun.disabled = false; btnNext.disabled = false;
      return;
    }

    const j = JSON.parse(raw);
    if (!j.ok || !j.prediction || !j.prediction.id){
      log("img2img error: no prediction id");
      btnRun.disabled = false; btnNext.disabled = false;
      return;
    }

    lastPredictionId = j.prediction.id;
    log(`image prediction id: ${lastPredictionId}`);

    const polled = await pollPrediction(lastPredictionId);
    if (!polled.ok){
      log("image poll error: " + polled.error);
      btnRun.disabled = false; btnNext.disabled = false;
      return;
    }

    const out = polled.prediction.output;
    const url = Array.isArray(out) ? out[0] : out;
    if (!url){
      log("image ok but no output url");
      btnRun.disabled = false; btnNext.disabled = false;
      return;
    }

    imgOut.onload = () => {
      imgOut.style.display = "block";
      log("image displayed ✅");
      btnRun.disabled = false; btnNext.disabled = false;
    };
    imgOut.onerror = () => {
      log("image load failed");
      btnRun.disabled = false; btnNext.disabled = false;
    };
    imgOut.src = url;
  }

  // ===== auto cycle (C) =====
  function startAuto(){
    stopAuto();
    autoOn = true;
    btnAuto.textContent = "Auto: ON";
    // every 18s: next headline → prompt → (optional auto-generate)
    autoTimer = setInterval(async () => {
      idx = (idx + 1) % items.length;
      setHeadline(idx);
      await derivePromptFromHeadline();
      // comment this line out if you *don’t* want auto image generation:
      await generateImageFromPrompt();
    }, 18000);
  }
  function stopAuto(){
    if (autoTimer) clearInterval(autoTimer);
    autoTimer = null;
    autoOn = false;
    btnAuto.textContent = "Auto: OFF";
  }

  // ===== UI events =====
  btnNext.addEventListener("click", async () => {
    if (!items.length) return;
    setHeadline(idx + 1);
    await derivePromptFromHeadline();
  });

  btnRun.addEventListener("click", async () => {
    await generateImageFromPrompt();
  });

  btnAuto.addEventListener("click", () => {
    if (autoOn) stopAuto();
    else startAuto();
  });

    // Auto-scroll loop (your original behavior)
  function startScroll(){
    setInterval(() => {
      if (inner.scrollTop < inner.scrollHeight - inner.offsetHeight) {
        inner.scrollTop += 1;
      } else {
        inner.scrollTop = 0;
      }
    }, 12);
  }

  // ===== boot =====
  async function boot(){
    log("boot… fetching BBC");
    const j = await getJSON(EP_BBC);
    if (!j.ok || !Array.isArray(j.items) || !j.items.length){
      headlineEl.textContent = "BBC feed error.";
      log("bbc error");
      return;
    }
    items = j.items;
    log(`bbc loaded ✅ (${items.length})`);

    setHeadline(0);
    await derivePromptFromHeadline();

    // auto on by default
    startAuto();
  }

  boot();
})();
</script>
</body>
</html>