<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>6Cards ‚Äî Vertical Diptych Scene Dissolve</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/* === Canvas setup === */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
function resize(){ 
  canvas.width = innerWidth; 
  canvas.height = innerHeight; 
}
addEventListener("resize", resize); 
resize();

/* === Replace WordPress video fetch with live camera === */
async function loadVideo(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:{ ideal:"environment" } },
      audio:false
    });

    const v = document.createElement("video");
    v.srcObject = stream;
    v.muted = true;
    v.playsInline = true;
    v.autoplay = true;
    v.style.display = "none";
    document.body.appendChild(v);

    await new Promise(res=>{
      const ready=()=>res();
      v.oncanplay = ready;
      v.onerror = ready;
      setTimeout(ready,1200);
    });

    v.play().catch(()=>{});
    console.log("üé• Live camera feed active");
    return v;

  }catch(e){
    console.error("‚ö†Ô∏è Camera access denied/unavailable", e);
    const errVid = document.createElement("video");
    errVid.loop = true;
    errVid.autoplay = true;
    errVid.muted = true;
    errVid.src = "fallback.mp4"; // optional backup
    document.body.appendChild(errVid);
    return errVid;
  }
}

/* === Basic unlock for iOS autoplay === */
function startVideos(){ 
  document.querySelectorAll("video").forEach(v=>v.play().catch(()=>{})); 
}
addEventListener("touchstart", startVideos, { once:true });
addEventListener("click", startVideos, { once:true });

/* === Card / Panel setup === */
let cards = [];
const NUM_CARDS = 6;
const CENTER_OVERLAP = 120;   
const STAGGER_X = 40;         

function initCards(vids){
  const W = canvas.width, H = canvas.height;
  const w = W / 2, h = H;
  cards = [];

  for (let i = 0; i < NUM_CARDS; i++) {
    const side = i < NUM_CARDS / 2 ? "left" : "right";
    const inward = (Math.random() - 0.5) * STAGGER_X;
    const xBase = side === "left"
      ? CENTER_OVERLAP + inward
      : (W / 2) - CENTER_OVERLAP + inward;

    cards.push({
      x: xBase,
      y: 0,
      w, h,
      side,
      vid: vids.length ? vids[i % vids.length] : null,
      dragging: false,
      offsetX: 0,
      offsetY: 0
    });
  }
}

/* === Draw helper === */
function drawVideoCover(vid,x,y,w,h,a=1){
  if(!vid||vid.readyState<2) return;
  const iw=vid.videoWidth||vid.width, ih=vid.videoHeight||vid.height;
  const r=Math.max(w/iw,h/ih);
  const nw=iw*r, nh=ih*r;
  const ox=x+(w-nw)/2, oy=y+(h-nh)/2;
  ctx.globalAlpha=a;
  ctx.drawImage(vid,ox,oy,nw,nh);
  ctx.globalAlpha=1;
}

/* === Fade manager === */
let activeFades=[];
function triggerFade(card,newVid){
  activeFades.push({card,oldVid:card.vid,newVid,progress:0});
}

/* === Sequential fade replace === */
async function sequentialFadeReplace(newVids){
  console.log("üé¨ Sequential fade replace...");
  for(const c of cards){
    const newVid=newVids[Math.floor(Math.random()*newVids.length)];
    triggerFade(c,newVid);
    await new Promise(r=>setTimeout(r,700));
  }
}

/* === Render loop === */
function render(){
  ctx.fillStyle="rgba(0,0,0,0.05)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  for(const c of cards){
    const fade=activeFades.find(f=>f.card===c);
    if(fade){
      fade.progress+=0.02;
      const p=Math.min(1,fade.progress);
      drawVideoCover(fade.oldVid,c.x,c.y,c.w,c.h,0.35*(1-p*0.8));
      drawVideoCover(fade.newVid,c.x,c.y,c.w,c.h,0.35*p);
      if(p>=1){ c.vid=fade.newVid; activeFades=activeFades.filter(f=>f!==fade); }
    }else{
      drawVideoCover(c.vid,c.x,c.y,c.w,c.h,0.35);
    }
  }
  requestAnimationFrame(render);
}

/* === Boot === */
(async function(){
  const v = await loadVideo();
  if(!v){ console.warn("‚ö†Ô∏è No videos found"); return; }
  initCards([v]);
  render();
})();
</script>
</body>
</html>
