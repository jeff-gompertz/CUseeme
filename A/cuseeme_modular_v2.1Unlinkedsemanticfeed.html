<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CUSeeMe v2.1 â€” Semantic Feed (BBC Reactive)</title>
<style>
/* =========================================================
Retro4.4 â€” Aqua Glass HUD + Minimal Ticker
Matches your v1.7 baseline look/feel
========================================================= */
:root{
  --hud-glass: rgba(185, 225, 255, 0.45);
  --hud-border-light: rgba(255, 255, 255, 0.65);
  --hud-border-dark: rgba(0, 45, 90, 0.35);
  --hud-shadow: 0 12px 45px rgba(0, 50, 90, 0.35);
  --hud-text: #1b1d22;
  --btn-bg: rgba(215, 235, 255, 0.35);
  --btn-inset-light: rgba(255,255,255,0.8);
  --btn-inset-dark: rgba(0,30,60,0.3);
  --bg: #f7f7f4;
  --ticker: #ff3a2f;
}
/* Disable all BBC hyperlink interactivity but keep visible for semantics */

a {
  pointer-events: none !important;
  cursor: default !important;
  text-decoration: none !important;
}

/* Soft cyan visible feed text */
body > a {
  color: rgba(150,200,255,0.4) !important;
}


/* ===== HUD (fixed, non-draggable) ===== */
#hudShell{
  position:fixed; top:24px; right:32px; z-index:1000;
  display:grid; gap:10px; padding:20px 18px 16px;
  min-width:320px; text-align:center; color:var(--hud-text);
  background:var(--hud-glass);
  border-radius:18px; border:1px solid var(--hud-border-light);
  box-shadow:
    inset 0 1px 3px var(--hud-border-light),
    inset 0 -1px 3px var(--hud-border-dark),
    var(--hud-shadow);
  backdrop-filter: blur(20px) saturate(1.25);
  -webkit-backdrop-filter: blur(20px) saturate(1.25);
}
#hudHeader{
  font-size:22px; color:rgba(20,30,45,0.85);
  text-shadow:0 1px 0 rgba(255,255,255,.6);
  user-select:none;
}
.hud-row{ display:flex; gap:10px; }
.hud-btn{
  flex:1; font:inherit; font-size:17px; cursor:pointer;
  color:#132030; background:var(--btn-bg); border:none; border-radius:10px;
  padding:10px 12px;
  box-shadow:
    inset 1px 1px 2px var(--btn-inset-light),
    inset -1px -2px 3px var(--btn-inset-dark),
    0 3px 6px rgba(0,0,0,0.08);
  transition:all .22s ease;
}
.hud-btn:hover{ transform:translateY(-1px); }
.hud-btn.on{
  background:rgba(255,165,100,0.18);
  color:#ff6a2f; font-weight:600;
  box-shadow:0 0 0 2px rgba(255,165,100,.25) inset;
}
#input{
  width:100%; font:inherit; font-size:18px; color:#111;
  background:rgba(255,255,255,.6);
  border:1px solid rgba(0,30,60,.15); border-radius:10px;
  padding:10px 12px; outline:none;
}

/* ===== Ticker (bottom-left; fills upward visually) ===== */
/* ===#ticker{
  position:fixed; left:16px; bottom:14px; z-index:900;
  width:45vw; max-width:700px; max-height:64vh;
  display:flex; flex-direction:column-reverse; overflow:hidden;
  color:var(--ticker); font-size:18px; line-height:1.25;
}==== */
  
#ticker{
  position:fixed; left:16px; bottom:14px; z-index:900;
  width:45vw; max-width:700px;
  display:flex; flex-direction:column-reverse;
  overflow:visible;        /* ğŸ‘ˆ allow it to grow infinitely upward */
  height:auto;             /* ğŸ‘ˆ remove container clip */
}
  
.tline{ opacity:.95; margin:0; animation:fadeIn .6s ease; }
.user{ color:#0d3b66; }
.sys{ color:#ff3a2f; }
.note{ color:#666; }
@keyframes fadeIn{ from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:none} }

/* ===== Hide raw Bloople output (anchors etc) ===== */
/* === Hide raw Bloople RSS output completely === */
body > a,
body > b,
body > h1,
body > p {
  display: none !important;
}
#rssSource, #rssSource * {
  display: none !important;
}

  
</style>
</head>
<body>

<!-- HUD -->
<div id="hudShell">
  <div id="hudHeader">Semantic Feed â€” BBC Reactive</div>
  <input id="input" placeholder="speak or typeâ€¦ then Enter" autocomplete="off" />
  <div class="hud-row">
    <button id="btnMic"  class="hud-btn" title="Start/Stop mic">ğŸ™ï¸ Mic</button>
    <button id="btnMute" class="hud-btn" title="Toggle spoken replies">ğŸ”Š Voice On</button>
    <button id="btnClear"class="hud-btn" title="Clear ticker">ğŸ§¹ Clear</button>
  </div>
</div>

<!-- Ticker -->
<div id="ticker"></div>

<!-- ===== BBC via Bloople (no CORS) ===== -->
<div id="rssSource" style="display:none;"></div>
<script src="//rss.bloople.net/?url=https%3A%2F%2Ffeeds.bbci.co.uk%2Fnews%2Fworld%2Frss.xml&showtitle=false&type=js"></script>

<script>
/* =========================================================
v2.1 â€” Semantic Core + Reactive BBC Blender
========================================================= */

// ---------- Ticker ----------
const ticker = document.getElementById('ticker');
function addLine(text, cls='sys'){
  const el = document.createElement('div');
  el.className = `tline ${cls}`;
  el.textContent = text;
  ticker.prepend(el);
  // if(ticker.children.length > 80) ticker.removeChild(ticker.lastChild);
}
addLine('v2.1 online â€” semantic core + BBC reactive blending', 'note');
addLine('Mic optional. Typing always works. Say: "time?", "repeat after me â€¦", or anything.', 'note');

// ---------- Speech Synthesis (reply) ----------
let speakEnabled = true;
let voicesReady = false;
function waitVoices(){
  return new Promise(res=>{
    const id = setInterval(()=>{
      if (speechSynthesis.getVoices().length){ clearInterval(id); voicesReady=true; res(); }
    }, 100);
  });
}
async function speak(text){
  if(!speakEnabled || !('speechSynthesis' in window)) return;
  if(!voicesReady) await waitVoices();
  const u = new SpeechSynthesisUtterance(text);
  // Prefer UK-ish voice to match your request
  u.lang = 'en-GB';
  u.rate = 1.02; u.pitch = 0.95; u.volume = 0.9;
  const v = speechSynthesis.getVoices();
  u.voice = v.find(x => /en-GB|UK|Kate|Samantha|Google UK English/i.test(x.name)) || v[0];
  speechSynthesis.speak(u);
}
document.getElementById('btnMute').addEventListener('click', ()=>{
  speakEnabled = !speakEnabled;
  const b = document.getElementById('btnMute');
  b.textContent = speakEnabled ? 'ğŸ”Š Voice On' : 'ğŸ”‡ Voice Off';
  b.classList.toggle('on', speakEnabled);
  addLine(`Spoken replies ${speakEnabled?'enabled':'disabled'}`, 'note');
});
// iOS/WebKit needs a user action before speaking reliably
window.addEventListener('touchstart', ()=> {
  try { speechSynthesis.speak(new SpeechSynthesisUtterance('')); } catch(_) {}
}, { once:true });

// ---------- BBC feed buffer (via Bloople injecting anchors) ----------
let feedBuffer = [];   // array of {title, ts}
function harvestHeadlines(){
  // Bloople injects into <body>; select anchors and dedupe by text
  const anchors = Array.from(document.body.querySelectorAll('a'));
  const titles = anchors.map(a => (a.textContent || '').trim()).filter(Boolean);
  const now = Date.now();
  titles.forEach(t => {
    if(!feedBuffer.some(x => x.title === t)){
      feedBuffer.push({ title: t, ts: now });
    }
  });
  // keep it tidy
  if(feedBuffer.length > 80) feedBuffer = feedBuffer.slice(-80);
}
setTimeout(harvestHeadlines, 1500);
setInterval(harvestHeadlines, 60000);

// Disable BBC anchor links (keep visible but inert)
setTimeout(() => {
  document.querySelectorAll('a').forEach(a => {
    a.removeAttribute('href');
  });
}, 2500); // wait 2.5s to ensure feed anchors exist

// ---------- Tiny keyword helper ----------
function keywordsFrom(text){
  return (text.toLowerCase()
    .replace(/[^a-z0-9\s]/g,' ')
    .split(/\s+/)
    .filter(w => w.length > 3 && !'about with into from that this what your have just will been they them than then here there which where only also because while after before could would should doing being hello thank'.includes(w))
  );
}

// ---------- Blend user text with BBC headlines ----------
function blendWithFeed(userText){
  if(feedBuffer.length === 0) return null;
  const keys = keywordsFrom(userText);
  let candidates = [];

  if(keys.length){
    // score headlines by keyword overlap
    candidates = feedBuffer
      .map(h => {
        const score = keys.reduce((s,k)=> s + (h.title.toLowerCase().includes(k) ? 1 : 0), 0);
        return { ...h, score };
      })
      .filter(x => x.score > 0)
      .sort((a,b) => b.score - a.score);
  }
  // If no keyword hits, fall back to a few random recent ones
  if(candidates.length === 0){
    const pool = feedBuffer.slice(-20);
    for(let i=0;i<3 && pool.length;i++){
      const idx = Math.floor(Math.random()*pool.length);
      candidates.push(pool.splice(idx,1)[0]);
    }
  }

  const pick = (arr, n) => {
    const out = [];
    const copy = arr.slice();
    while(n-- > 0 && copy.length){
      out.push(copy.splice(Math.floor(Math.random()*copy.length),1)[0]);
    }
    return out;
  };

  const chosen = pick(candidates, 2).map(x => x.title);
  const stems = [
    'signal echoes:',
    'semantic crossover:',
    'field resonance:',
    'adjacent headline:',
    'network murmur:',
    'latent alignment:'
  ];
  const stem = stems[Math.floor(Math.random()*stems.length)];

  if(chosen.length === 1){
    return `${stem} ${chosen[0]}`;
  }else if(chosen.length === 2){
    // lightly â€œsurrealâ€ stitch
    const [a,b] = chosen;
    // trim punctuation for nicer join
    const A = a.replace(/[â€“â€”-]\s.*$/,'').replace(/\.$/,'');
    const B = b.replace(/^[A-Z].{0,10}:\s*/,'');
    return `${stem} ${A} â€” ${B}.`;
  }else{
    return 'channel quiet.';
  }
}

// ---------- Semantic router (no side effects beyond ticker + speak) ----------
function semanticRouter(raw){
  const text = (raw||'').trim();
  if(!text) return;
  addLine('> ' + text, 'user');

  const lower = text.toLowerCase();
  if (lower === 'hello' || lower.startsWith('hi')) {
    const reply = "Hello. I'm listening.";
    addLine(reply, 'sys'); speak(reply);
  } else if (lower.includes('time')) {
    const reply = 'Current time: ' + new Date().toLocaleTimeString();
    addLine(reply, 'sys'); speak(reply);
  } else if (lower.startsWith('repeat after me')) {
    const say = text.replace(/^repeat after me/i, '').trim() || 'â€¦say what?';
    addLine(say, 'sys'); speak(say);
  } else {
    // default echo
    const echo = 'You said: ' + text;
    addLine(echo, 'sys'); speak(echo);
  }

  // Then the reactive blend line
  const blend = blendWithFeed(text);
  if(blend){
    setTimeout(()=>{
      addLine(blend, 'sys');
      speak(blend);
    }, 500); // slight delay for cadence
  }
}

// ---------- Input (text) ----------
const input = document.getElementById('input');
input.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    e.preventDefault();
    semanticRouter(input.value);
    input.value = '';
  }
});

// ---------- Voice input (if available) ----------
const btnMic = document.getElementById('btnMic');
let rec = null, listening = false;
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
if (!SR) {
  btnMic.addEventListener('click', ()=>{
    addLine('Mic recognition not available on this browser. Typing still works.', 'note');
  });
} else {
  rec = new SR();
  rec.lang = 'en-US';
  rec.interimResults = true;
  rec.continuous = true;

  rec.onstart = () => { listening = true; btnMic.classList.add('on'); addLine('ğŸ™ï¸ Voice capture started', 'note'); };
  rec.onend   = () => { listening = false; btnMic.classList.remove('on'); addLine('â¹ï¸ Voice capture stopped', 'note'); };

  let interim = '';
  rec.onresult = (evt)=>{
    let finalChunk = '';
    for (let i = evt.resultIndex; i < evt.results.length; i++) {
      const t = evt.results[i][0].transcript;
      if (evt.results[i].isFinal) finalChunk += t;
      else interim = t;
    }
    if (finalChunk) {
      document.getElementById("input").value = finalChunk;
      semanticRouter(finalChunk);
      interim = '';
    }
  };
  rec.onerror = (e)=>{ addLine('Voice error: ' + e.error, 'note'); };

  btnMic.addEventListener('click', ()=>{
    try{ if(!listening){ rec.start(); } else { rec.stop(); } }
    catch(err){ addLine('Mic error: ' + (err.message||err), 'note'); }
  });
}

// ---------- Clear ----------
document.getElementById('btnClear').addEventListener('click', ()=>{
  ticker.innerHTML = '';
});

// ---------- First pulse ----------
setTimeout(()=> addLine('BBC headlines linked. Waiting for your inputâ€¦', 'note'), 1200);

</script>
</body>
</html>
