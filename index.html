Copilot navigation 


<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>CUSeeMe v1.8 â€” Floating Feed (Live Black)</title>
<style>
html,body{
  margin:0;padding:0;height:100%;
  background:#000;
  font-family:"VT323", monospace;
  color:#0f0;
  overflow:hidden;
}

/* === MAIN CAMERA FEED === */
#camera{
  position:fixed;inset:0;
  object-fit:cover;
  transform:scaleX(-1);
  z-index:0;
  filter:brightness(1.05) contrast(1.1);
}

/* === FLOATING MINI FEED === */
#miniFeed{
  position:absolute;
  top:24px;right:24px;
  width:240px;height:180px;
  border-radius:10px;
  overflow:hidden;
  z-index:2;
  background:rgba(255,255,255,0.04);
  border:1px solid rgba(255,255,255,0.15);
  backdrop-filter:blur(4px);
  cursor:grab;
  transition:box-shadow .3s ease, transform .4s ease;
} 
#miniFeed video{
  width:100%;height:100%;
  object-fit:cover;
  transform:scaleX(-1);
  opacity:0.9;
}
#miniFeed:hover{
  box-shadow:0 0 20px rgba(0,255,120,0.25);
  transform:scale(1.04);
}

/* === PROMPT LAYER ===
*/
#promptWrap{
  position:fixed;inset:0;display:flex;
  align-items:center;justify-content:center;
  z-index:3;pointer-events:none;
}
#promptBox{
  pointer-events:auto;
  background:rgba(0,255,100,0.1);
  border:1px solid rgba(0,255,100,0.25);
  border-radius:10px;
  padding:.6rem 1rem;
  font-size:1.8rem;
  display:flex;align-items:center;gap:.4rem;
  color:#0f0;
}
#input{
  background:transparent;
  border:none;outline:none;
  color:#ffffff;
  font-size:inherit;
  width:14ch;
}
#input::placeholder{
  color: rgba(255,255,255,0.6);
}
#caret{
  width:.25ch;height:1.3em;background:#0f0;
  animation:blink 1s step-end infinite;
}
@keyframes blink{50%{opacity:0}}

/* Dictation button styles */
#dictateBtn{
  background:transparent;
  border:1px solid rgba(0,255,120,0.12);
  color:#0f0;
  font-size:1.25rem;
  padding:6px 8px;
  border-radius:8px;
  cursor:pointer;
  margin-left:6px;
  line-height:1;
}
#dictateBtn.listening{
  color:#ff0;
  border-color:rgba(255,12,110,0.9);
  box-shadow:0 0 18px rgba(255,12,110,0.35), inset 0 0 8px rgba(255,60,160,0.12);
  transform:scale(1.05);
}

/* === TICKER === */
#ticker{
  position:fixed;
  left:14px;bottom:14px;
  width:40%;
  max-height:55%;
  display:flex;flex-direction:column-reverse;
  overflow:hidden;
  z-index:3;
  font-size:1rem;line-height:1.2rem;
  color:#0f0;opacity:.9;
}
.tline{
  opacity:.8;margin:0;
  animation:fadeIn 1s ease forwards;
  transition:opacity 45s linear;
}
@keyframes fadeIn{
  from{opacity:0;transform:translateY(10px)}
  to{opacity:.8;transform:translateY(0)}
}

/* === TOGGLE BUTTONS === */
#hudToggle{
  position:fixed;top:12px;right:12px;z-index:4;
  background:rgba(0,255,80,0.1);
  border:1px solid rgba(0,255,120,0.2);
  border-radius:6px;
  color:#0f0;
  font-size:12px;
  padding:6px 10px;
  cursor:pointer;
  backdrop-filter:blur(3px);
}
#hudToggle:hover{background:rgba(0,255,120,0.25);} 

#hudToggle_nav{
  position:fixed;top:48px;right:12px;z-index:4;
  background:rgba(0,255,80,0.1);
  border:1px solid rgba(0,255,120,0.2);
  border-radius:6px;
  color:#0f0;
  font-size:12px;
  padding:6px 10px;
  cursor:pointer;
  backdrop-filter:blur(3px);
  user-select:none;
  -webkit-user-select:none;
  touch-action:manipulation;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  position:fixed;
}

/* Strong neon reddish-pink hold-state (high contrast with green) */
#hudToggle_nav.holding{
  background:linear-gradient(90deg, rgba(255,12,110,0.26), rgba(255,40,140,0.12));
  box-shadow:0 0 64px rgba(255,12,110,0.95), inset 0 0 36px rgba(255,60,160,0.32);
  transform:scale(1.06);
  border-color:rgba(255,12,110,0.7);
}

/* progress indicator inside the button (grows leftâ†’right while holding) */
#hudToggle_nav .holdProgress{
  position:absolute;
  left:0;top:0;height:100%;width:0%;
  border-radius:6px;
  background:linear-gradient(90deg, rgba(255,12,110,0.28), rgba(255,60,160,0.16));
  pointer-events:none;
  transition:width 0s linear;
  z-index:-1;
}

/* status bubble */
#repoStatus{
  position:fixed;top:12px;right:120px;z-index:6;
  color:#b8ffb8;font-size:13px;padding:6px 8px;
  background:rgba(0,0,0,0.35);border:1px solid rgba(0,255,120,0.06);
  border-radius:6px;pointer-events:none;opacity:.95
}

/* === REPO NAV SIDEBAR === */
.repo-nav{
  position:fixed;
  top:0;right:0;
  height:100%;
  width:360px;
  max-width:90%;
  background:linear-gradient(180deg, rgba(0,0,0,0.9), rgba(0,0,0,0.85));
  border-left:1px solid rgba(0,255,120,0.08);
  z-index:5;
  padding:12px;
  box-sizing:border-box;
  color:#b8ffb8;
  display:flex;
  flex-direction:column;
  gap:8px;
  transform:translateX(110%);
  transition:transform .35s cubic-bezier(.2,.9,.2,1),opacity .25s;
  opacity:0;
  pointer-events:none;
  font-size:14px;
  overflow:auto;
}
.repo-nav.open{
  transform:translateX(0);
  opacity:1;
  pointer-events:auto;
}
.repo-nav header{
  display:flex;align-items:center;justify-content:space-between;gap:8px;
  border-bottom:1px dashed rgba(0,255,120,0.06);
  padding-bottom:8px;margin-bottom:6px;
}
.repo-nav .controls button{
  background:transparent;border:1px solid rgba(0,255,120,0.06);color:#0f0;padding:6px;border-radius:6px;cursor:pointer;
}
.repo-nav .list{display:block;}
.repo-nav a{
  display:block;padding:6px 8px;border-radius:6px;color:#9ffea0;text-decoration:none;
  font-size:13px;margin:4px 0;
}
.repo-nav a:hover{background:rgba(0,255,120,0.04);text-decoration:underline;}
.repo-nav .dir{font-weight:700;color:#c8ffd0}
.repo-nav .meta{font-size:11px;color:#7fffb0;opacity:.8;margin-bottom:8px}

/* small screens adjust */
@media (max-width:640px){
  .repo-nav{width:92%}
  #miniFeed{width:180px;height:140px}
}
</style>
</head>
<body>
<video id="camera" autoplay muted playsinline></video>

<div id="miniFeed">
  <video id="miniVideo" autoplay muted playsinline></video>
</div>

<div id="hudToggle">â§‰ FLOAT</div>

<!-- NAV button contains a progress element -->
<div id="hudToggle_nav" role="button" aria-pressed="false" aria-label="Hold to open navigation">
  <div class="holdProgress" aria-hidden="true"></div>
  â§‰ NAV
</div>

<div id="repoStatus">nav: idle</div>

<!-- Repository navigation / file browser -->
<aside id="repoNav" class="repo-nav" aria-hidden="true">
  <header>
    <div>
      <div style="font-family:inherit;font-weight:700">Repository navigation</div>
      <div class="meta" id="repoMeta">loading...</div>
    </div>
    <div class="controls">
      <button id="repoRefresh" title="Refresh">âŸ³</button>
      <button id="repoClose" title="Close">âœ•</button>
    </div>
  </header>
  <nav id="repoList" class="list" role="navigation" aria-label="Repository files"></nav>
  <div style="margin-top:auto;font-size:12px;color:#7fffb0;opacity:.7;padding-top:10px">
    Tip: click file to open on GitHub (opens in new tab). You can instantiate the nav with createRepoNav(owner, repo, branch).
  </div>
</aside>

<div id="promptWrap">
  <div id="promptBox">
    <div id="caret"></div>
    <input id="input" type="text" spellcheck="false" autocomplete="off" placeholder="type here...">
    <button id="dictateBtn" type="button" aria-label="Start dictation" title="Start dictation">ðŸŽ¤</button>
  </div>
</div>

<div id="ticker"></div>

<script>
function setRepoStatus(msg){
  var el=document.getElementById('repoStatus');
  if(el) el.textContent = 'nav: '+msg;
}

/* === CAMERA INIT === */
(async()=>{
  const cam=document.getElementById('camera');
  const mini=document.getElementById('miniVideo');
  try{
    const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:"environment"}},audio:false});
    cam.srcObject=stream;
    mini.srcObject=stream;
  }catch(e){
    const msg="âš  camera access denied/unavailable";
    document.body.style.background="#111";
    console.warn(msg);
    const t=document.createElement("div");
    t.textContent=msg;
    t.style.position="fixed";t.style.top="50%";t.style.left="50%";
    t.style.transform="translate(-50%,-50%)";
    t.style.color="#0f0";
    document.body.appendChild(t);
  }
})();

/* === DRAGGABLE MINI FEED === */
(()=>{
  const el=document.getElementById('miniFeed');
  let down=false,ox=0,oy=0;
  const start=e=>{
    down=true;
    ox=(e.touches?e.touches[0].clientX:e.clientX)-el.offsetLeft;
    oy=(e.touches?e.touches[0].clientY:e.clientY)-el.offsetTop;
    el.style.cursor='grabbing';
  };
  const move=e=>{
    if(!down)return;
    const cx=(e.touches?e.touches[0].clientX:e.clientX);
    const cy=(e.touches?e.touches[0].clientY:e.clientY);
    el.style.left=(cx-ox)+'px';
    el.style.top=(cy-oy)+'px';
    if(e.preventDefault) e.preventDefault();
  };
  const stop=()=>{down=false;el.style.cursor='grab';};
  el.addEventListener('mousedown',start);
  el.addEventListener('touchstart',start,{passive:false});
  window.addEventListener('mousemove',move);
  window.addEventListener('touchmove',move,{passive:false});
  window.addEventListener('mouseup',stop);
  window.addEventListener('touchend',stop);
})();

/* === TOGGLE MINI FEED === */
const mini=document.getElementById('miniFeed');
document.getElementById('hudToggle').addEventListener('click',()=>{
  mini.style.display=mini.style.display==='none'?'block':'none';
});

/* === TICKER === */
const ticker=document.getElementById('ticker');
function addTickerLine(text){
  const el=document.createElement('div');
  el.className='tline';
  el.textContent=text;
  ticker.prepend(el);
  if(ticker.children.length>40)ticker.removeChild(ticker.lastChild);
  setTimeout(function(){el.style.opacity=0.15;},45000);
}

/* === SPEECH SYNTHESIS === */
var voicesReady=false;
function waitForVoices(){
  return new Promise(function(resolve){
    if(voicesReady && speechSynthesis.getVoices().length) return resolve();
    var id=setInterval(function(){
      if(speechSynthesis.getVoices().length){clearInterval(id);voicesReady=true;resolve();}
    },100);
  });
}
async function speak(text){
  if(!('speechSynthesis' in window)) return;
  await waitForVoices();
  var u=new SpeechSynthesisUtterance(text);
  u.rate=1.05;u.pitch=0.9;u.volume=0.8;u.lang='en-US';
  var v=speechSynthesis.getVoices();
  u.voice=v.find(function(x){ return /samantha/i.test(x.name); })||v.find(function(x){ return /google/i.test(x.name); })||v[0];
  speechSynthesis.speak(u);
}
window.addEventListener('touchstart',function(){speechSynthesis.speak(new SpeechSynthesisUtterance(''));},{once:true});

/* === INPUT HANDLER === */
var input=document.getElementById('input');
input.addEventListener('keydown',function(e){
  if(e.key!=='Enter')return;
  var val=input.value.trim();
  if(!val)return;
  addTickerLine('> '+val);
  input.value='';
  var replies=[
    'system echo: "'+val+'" acknowledged',
    'latency: '+(Math.random()*0.8+0.2).toFixed(2)+' s',
    '"'+val+'" mirrored in floating feed',
    'drift vector stabilized',
    'resonance: '+Math.floor(Math.random()*100)+'%'
  ];
  var reply=replies[Math.floor(Math.random()*replies.length)];
  setTimeout(function(){
    addTickerLine('< '+reply);
    speak(reply);
  },600);
});

/* === DIAGNOSTIC FEED === */
var diagnostics=[
  "calibrating optical link...",
  "signal noise threshold: 0.72",
  "field sync nominal",
  "mirror node online",
  "loopback handshake OK"
];
setInterval(function(){
  var msg=diagnostics[Math.floor(Math.random()*diagnostics.length)];
  addTickerLine(msg);
},6500);

/* === Repository navigation component === */
(function globalRepoNavFactory(){
  function RepoNav(opts){
    this.owner = opts.owner;
    this.repo = opts.repo;
    this.branch = opts.branch || 'main';
    this.container = document.getElementById(opts.containerId || 'repoNav');
    this.list = document.getElementById(opts.listId);
    this.meta = document.getElementById(opts.metaId);
    this.statusEl = document.getElementById('repoStatus');
    if(!this.container || !this.list) throw new Error('RepoNav container/list not found');
    this.apiBase = 'https://api.github.com/repos/'+this.owner+'/'+this.repo+'/contents';
    this.blobBase = 'https://github.com/'+this.owner+'/'+this.repo+'/blob/'+this.branch;
    this._open = false;
    this.initUI();
  }
  RepoNav.prototype.initUI = function(){
    var self=this;
    var refreshBtn = document.getElementById('repoRefresh');
    var closeBtn = document.getElementById('repoClose');
    if(refreshBtn) refreshBtn.addEventListener('click',function(){ self.refresh(); });
    if(closeBtn) closeBtn.addEventListener('click',function(){ self.close(); });
    document.addEventListener('keydown', function(e){ if(e.key==='Escape' && self._open) self.close(); });
    if(this.meta) this.meta.textContent = this.owner+'/'+this.repo+' Â· branch: '+this.branch;
  };
  RepoNav.prototype.refresh = async function(){
    if(this.list) this.list.innerHTML = '<div style="opacity:.6">loadingâ€¦</div>';
    if(this.statusEl) setRepoStatus('loading');
    try{
      await this.renderPath('');
      if(this.statusEl) setRepoStatus('loaded');
    }catch(err){
      if(this.list) this.list.innerHTML = '<div style="color:#ffb8b8">failed to load repository: '+(err.message||'unknown')+'</div>';
      if(this.statusEl) setRepoStatus('error â€” '+(err.message||'unknown'));
    }
  };
  RepoNav.prototype.fetchContents = async function(path){
    var url = this.apiBase+'/'+encodeURI(path)+'?ref='+encodeURIComponent(this.branch);
    var resp = await fetch(url);
    if(!resp.ok){
      var txt = await resp.text().catch(function(){ return resp.statusText; });
      throw new Error('GitHub API '+resp.status+' â€” '+txt);
    }
    return resp.json();
  };
  RepoNav.prototype.renderPath = async function(path){
    try{
      var items = await this.fetchContents(path || '');
      var list = Array.isArray(items) ? items : [items];
      list.sort(function(a,b){
        if(a.type===b.type) return a.name.localeCompare(b.name);
        return a.type === 'dir' ? -1 : 1;
      });
      this.list.innerHTML = '';
      if(path){
        var up = document.createElement('a');
        up.href='#';
        up.className='dir';
        up.textContent='.. (up)';
        up.addEventListener('click', (function(self){ return function(e){ if(e.preventDefault) e.preventDefault(); var parent = path.split('/').slice(0,-1).join('/'); self.renderPath(parent); }; })(this));
        this.list.appendChild(up);
      }
      for(var i=0;i<list.length;i++){ 
        var it=list[i];
        var el=document.createElement('a');
        el.textContent = it.name + (it.type==='dir' ? '/' : '');
        if(it.type === 'dir'){ 
          el.className = 'dir';
          el.href = '#';
          (function(self, itEl){
            itEl.addEventListener('click', function(e){ if(e.preventDefault) e.preventDefault(); self.renderPath(it.path); });
          })(this, el);
        } else { 
          el.target = '_blank';
          el.rel = 'noopener noreferrer';
          el.href = this.blobBase + '/' + it.path;
        }
        this.list.appendChild(el);
      }
    }catch(err){
      console.warn('RepoNav fetch failed:', err);
      this.list.innerHTML = '';
      var fallbackIntro = document.createElement('div');
      fallbackIntro.style.opacity = '.8';
      fallbackIntro.textContent = 'Could not load via API â€” fallback links:';
      this.list.appendChild(fallbackIntro);
      var fallbackPaths = [
        {label:'Repository on GitHub', href:'https://github.com/'+this.owner+'/'+this.repo},
        {label:'README', href:'https://github.com/'+this.owner+'/'+this.repo+'/blob/'+this.branch+'/README.md'},
        {label:'This file', href:'https://github.com/'+this.owner+'/'+this.repo+'/blob/'+this.branch+'/a_copilot_backup_navigation.html'}
      ];
      for(var j=0;j<fallbackPaths.length;j++){ 
        var f=fallbackPaths[j];
        var a=document.createElement('a');
        a.href=f.href; a.target='_blank'; a.rel='noopener noreferrer';
        a.textContent = f.label;
        this.list.appendChild(a);
      }
      if(this.statusEl) setRepoStatus('fallback â€” see list');
    }
  };
  RepoNav.prototype.open = async function(){
    if(!this._open){
      this.container.classList.add('open');
      this.container.setAttribute('aria-hidden','false');
      this._open=true;
      await this.refresh();
    }
  };
  RepoNav.prototype.close = function(){
    if(this._open){
      this.container.classList.remove('open');
      this.container.setAttribute('aria-hidden','true');
      this._open=false;
    }
  };
  RepoNav.prototype.toggle = function(){
    return this._open ? this.close() : this.open();
  };

  window.createRepoNav = function(opts){
    if(!opts || !opts.owner || !opts.repo) throw new Error('owner and repo required to create repo nav');
    return new RepoNav(opts);
  };
})(); // end factory

// instantiate for this repo
var repoNavInstance = createRepoNav({ owner: 'jeff-gompertz', repo: 'CUseeme', branch: 'main', containerId: 'repoNav', listId: 'repoList', metaId: 'repoMeta' });

/* === Hold-to-open behavior for NAV button === */
(function attachHoldToOpen(){
  var btn = document.getElementById('hudToggle_nav');
  var progress = btn.querySelector('.holdProgress');
  var holdThreshold = 1400; // milliseconds required to open (doubled per request)
  var holdTimer = null;
  var triggered = false;
  var startX = 0, startY = 0;
  var moved = false;
  var maxMove = 12; // px allowed before cancelling

  function startHold(clientX, clientY){
    triggered = false;
    moved = false;
    startX = clientX;
    startY = clientY;
    btn.classList.add('holding');
    if(progress){
      progress.style.transition = 'width '+holdThreshold+'ms linear';
      progress.style.width = '1%';
      // small delay to ensure transition runs
      setTimeout(function(){ progress.style.width = '100%'; }, 10);
    }
    holdTimer = setTimeout(function(){
      triggered = true;
      if(btn.getAttribute('aria-pressed') === 'false') btn.setAttribute('aria-pressed','true');
      repoNavInstance.open();
      setRepoStatus('opened');
      // clear visual shortly after
      clearHoldVisual();
    }, holdThreshold);
    setRepoStatus('holding');
  }

  function clearHoldVisual(){
    btn.classList.remove('holding');
    if(progress){
      progress.style.transition = 'width 160ms linear';
      progress.style.width = '0%';
    }
    if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
    setTimeout(function(){ if(btn.getAttribute('aria-pressed') === 'true') btn.setAttribute('aria-pressed','false'); }, 350);
  }

  function cancelHold(){
    if(holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
    triggered = false;
    clearHoldVisual();
    setRepoStatus('cancelled');
  }

  // touch handlers
  btn.addEventListener('touchstart', function(e){
    if(!e.touches || !e.touches[0]) return;
    var t = e.touches[0];
    startHold(t.clientX, t.clientY);
  }, {passive:true});

  btn.addEventListener('touchmove', function(e){
    if(!e.touches || !e.touches[0]) return;
    var t = e.touches[0];
    var dx = Math.abs(t.clientX - startX);
    var dy = Math.abs(t.clientY - startY);
    if(dx > maxMove || dy > maxMove){
      moved = true;
      cancelHold();
    }
  }, {passive:true});

  btn.addEventListener('touchend', function(e){
    if(triggered){
      // already opened
      clearHoldVisual();
    } else {
      cancelHold();
    }
  });

  btn.addEventListener('touchcancel', function(e){
    cancelHold();
  });

  // mouse handlers (desktop)
  btn.addEventListener('mousedown', function(e){
    // left click only
    if(e.button !== 0) return;
    startHold(e.clientX, e.clientY);
    function onMove(ev){
      var dx = Math.abs(ev.clientX - startX);
      var dy = Math.abs(ev.clientY - startY);
      if(dx > maxMove || dy > maxMove){ moved = true; cancelHold(); document.removeEventListener('mousemove', onMove); }
    }
    function onUp(ev){
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      if(triggered){
        clearHoldVisual();
      } else {
        cancelHold();
      }
    }
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  // accessibility: also support keyboard long-press via keydown (Space/Enter held)
  var keyHoldTimer = null;
  btn.addEventListener('keydown', function(e){
    if(e.key===' ' || e.key==='Enter'){
      if(keyHoldTimer) return;
      startHold(0,0);
      keyHoldTimer = setTimeout(function(){
        // timer expired (triggered)
        keyHoldTimer = null;
      }, holdThreshold);
      if(e.key===' ') { if(e.preventDefault) e.preventDefault(); }
    }
  });
  btn.addEventListener('keyup', function(e){
    if(e.key===' ' || e.key==='Enter'){
      if(keyHoldTimer){ clearTimeout(keyHoldTimer); keyHoldTimer=null; cancelHold(); }
      else {
        // if timer already fired, visually clear
        clearHoldVisual();
      }
    }
  });

  // avoid immediate close right after opening
  var lastOpenedAt = 0;
  (function(){
    var origOpen = repoNavInstance.open.bind(repoNavInstance);
    repoNavInstance.open = async function(){
      lastOpenedAt = Date.now();
      return origOpen();
    };
  })();

  document.addEventListener('click', function(e){
    var nav = document.getElementById('repoNav');
    var toggle = document.getElementById('hudToggle_nav');
    if(!nav.contains(e.target) && !toggle.contains(e.target)){ 
      if(Date.now() - lastOpenedAt < 350) return;
      repoNavInstance.close();
    }
  });

})(); // end hold-to-open

/* === In-page dictation (Web Speech API) === */
(function enableInPageDictation(){
  const inputEl = document.getElementById('input');
  const btn = document.getElementById('dictateBtn');
  const box = document.getElementById('promptBox');
  if(!inputEl || !box) return;

  // helper to safe-focus the input (needed for iOS keyboard dictation fallback)
  function focusInput(){
    try { inputEl.focus({ preventScroll:true }); } catch(e){ inputEl.focus(); }
  }

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || null;
  let recognition = null;
  let listening = false;

  function setListeningState(on){
    listening = !!on;
    if(btn){
      if(listening){
        btn.classList.add('listening');
        btn.textContent = 'âºï¸';
      } else {
        btn.classList.remove('listening');
        btn.textContent = 'ðŸŽ¤';
      }
    }
  }

  if(btn){
    btn.addEventListener('click', async function(){
      if(SpeechRecognition){
        if(!recognition){
          recognition = new SpeechRecognition();
          recognition.lang = 'en-US';
          recognition.interimResults = false;
          recognition.maxAlternatives = 1;
          recognition.continuous = false;
          recognition.onstart = function(){
            setListeningState(true);
            addTickerLine('â†’ dictation: listeningâ€¦ (browser will prompt for microphone permission)');
          };
          recognition.onresult = function(ev){
            const transcript = Array.from(ev.results).map(r => r[0].transcript).join(' ');
            inputEl.value = (inputEl.value ? inputEl.value + ' ' : '') + transcript;
            addTickerLine('< dictation: '+transcript);
          };
          recognition.onerror = function(err){
            console.warn('SpeechRecognition error', err);
            addTickerLine('âš  dictation error: '+(err.error||err.message||'unknown'));
            alert('Speech recognition error: ' + (err.error || err.message || 'unknown'));
          };
          recognition.onend = function(){
            setListeningState(false);
          };
        }

        try{
          if(listening){
            recognition.stop();
            setListeningState(false);
          } else {
            recognition.start();
          }
        }catch(err){
          console.warn('Recognition start/stop failed', err);
          setListeningState(false);
        }
      } else {
        // Fallback for iOS Safari (no Web Speech API): focus input and instruct user to use keyboard dictation
        focusInput();
        addTickerLine('â†’ Focused input for iOS keyboard dictation. Tap the keyboard microphone to start.');
        setTimeout(()=>{ try{ inputEl.scrollIntoView({behavior:'smooth', block:'center'}); }catch(e){} }, 120);
      }
    });
  }

  // Ensure the input is focusable for native keyboard dictation
  try{
    inputEl.removeAttribute && inputEl.removeAttribute('readonly');
  }catch(e){}
  inputEl.disabled = false;
  inputEl.setAttribute('autocapitalize','sentences');
  inputEl.setAttribute('autocorrect','on');
  inputEl.setAttribute('inputmode','text');
})();
</script>
</body>
</html>
