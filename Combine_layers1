<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shader + Floating Windows</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: black;
  }

  /* Shader background canvas */
  #shader {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    z-index: -1;
  }

  /* Floating windows */
  .floating-window {
    position: absolute;
    width: 390px;
    height: 260px;
    overflow: hidden;
    border: none;
    box-shadow: 0 0 25px rgba(0,0,0,0.4);
    cursor: grab;
    background: rgba(255,255,255,0.05);
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  .floating-window:active { cursor: grabbing; }

  .floating-window iframe {
    width: 100%;
    height: 100%;
    border: none;
    pointer-events: none; /* let drag work */
  }
</style>
</head>
<body>

<!-- Background shader -->
<canvas id="shader"></canvas>

<!-- Floating windows -->
<div id="windows"></div>

<script>
/* ========== Shader setup (fragment shader, simple plasma style) ========== */
const canvas = document.getElementById('shader');
const gl = canvas.getContext('webgl');
canvas.width = innerWidth;
canvas.height = innerHeight;
gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);

const vs = `
  attribute vec4 position;
  void main() { gl_Position = position; }
`;

const fs = `
  precision mediump float;
  uniform float u_time;
  uniform vec2 u_res;
  void main() {
    vec2 uv = gl_FragCoord.xy / u_res.xy;
    float color = 0.5 + 0.5 * cos(u_time + uv.xyx + vec3(0,2,4));
    gl_FragColor = vec4(color, 1.0);
  }
`;

function compileShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  return s;
}
const prog = gl.createProgram();
gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const vertices = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(prog, 'position');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const timeLoc = gl.getUniformLocation(prog, 'u_time');
const resLoc = gl.getUniformLocation(prog, 'u_res');
gl.uniform2f(resLoc, canvas.width, canvas.height);

function render(t) {
  gl.uniform1f(timeLoc, t*0.001);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>

<script>
/* ========== Floating windows logic (RSS â†’ draggable) ========== */
const container = document.getElementById("windows");
const W = () => window.innerWidth;
const H = () => window.innerHeight;

const feedUrl = "https://www.youtube.com/feeds/videos.xml?channel_id=UCREEmHdAYvlboosrKCHe4UA";

fetch("https://api.rss2json.com/v1/api.json?rss_url=" + encodeURIComponent(feedUrl))
  .then(res => res.json())
  .then(data => {
    const items = data.items || [];
    const videos = items.sort(() => 0.5 - Math.random()).slice(0, 4);

    videos.forEach((video) => {
      const div = document.createElement("div");
      div.className = "floating-window";

      const x = Math.max(0, Math.min(W() - 390, Math.random() * (W() - 390)));
      const y = Math.max(0, Math.min(H() - 260, Math.random() * (H() - 260)));
      div.style.left = x + "px";
      div.style.top  = y + "px";

      const vidId = (video.guid || "").split(':').pop();
      div.innerHTML = `
        <iframe
          src="https://www.youtube.com/embed/${vidId}?autoplay=1&mute=1&loop=1&playlist=${vidId}"
          allow="autoplay; encrypted-media"
          allowfullscreen
        ></iframe>
      `;

      container.appendChild(div);
      makeDraggableAndBouncing(div);
    });
  });

function makeDraggableAndBouncing(el) {
  let dragging = false;
  let offsetX = 0, offsetY = 0;
  let vx = (Math.random() * 2 - 1) * 0.6;
  let vy = (Math.random() * 2 - 1) * 0.6;

  el.addEventListener("pointerdown", (e) => {
    dragging = true;
    el.setPointerCapture(e.pointerId);
    offsetX = e.clientX - el.offsetLeft;
    offsetY = e.clientY - el.offsetTop;
    el.style.cursor = "grabbing";
  });

  el.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    let x = e.clientX - offsetX;
    let y = e.clientY - offsetY;
    x = Math.max(0, Math.min(W() - el.offsetWidth, x));
    y = Math.max(0, Math.min(H() - el.offsetHeight, y));
    el.style.left = x + "px";
    el.style.top  = y + "px";
  });

  el.addEventListener("pointerup", (e) => {
    dragging = false;
    el.style.cursor = "grab";
    try { el.releasePointerCapture(e.pointerId); } catch {}
  });

  function animate() {
    if (!dragging) {
      let x = el.offsetLeft + vx;
      let y = el.offsetTop + vy;
      if (x <= 0 || x + el.offsetWidth >= W()) vx *= -1;
      if (y <= 0 || y + el.offsetHeight >= H()) vy *= -1;
      el.style.left = Math.max(0, Math.min(W() - el.offsetWidth, x)) + "px";
      el.style.top  = Math.max(0, Math.min(H() - el.offsetHeight, y)) + "px";
    }
    requestAnimationFrame(animate);
  }
  animate();
}
</script>

</body>
</html>
