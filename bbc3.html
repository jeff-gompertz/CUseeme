<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BBC two</title>

<style>
/* =========================================================
Retro4.4 â€” Aqua Glass HUD + Minimal Ticker
Refined for v2.1 Unlinked â€” proper spacing & font balance
========================================================= */

:root {
  --hud-glass: rgba(185, 225, 255, 0.18);
  --hud-border-light: rgba(255, 255, 255, 0.22);
  --hud-border-dark: rgba(0, 45, 90, 0.06);
  --hud-shadow: 0 12px 45px rgba(0, 50, 90, 0.25);
  --hud-text: #dfffe6;
  --btn-bg: rgba(255,255,255,0.04);
  --btn-inset-light: rgba(255,255,255,0.06);
  --btn-inset-dark: rgba(0,30,60,0.06);
  --bg: #000000;
  --ticker: #ff3a2f;
  --orange: #ff7a30;
}

/* page background */
html,body{height:100%;margin:0;background:var(--bg);color:var(--hud-text);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}

/* centered minimalist prompt area (responsive) */
#centerWrap{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  box-sizing:border-box;
  pointer-events: none; /* allow the small controls to capture events */
}
.centerCard{
  pointer-events:auto;
  width:min(820px,94vw);
  max-width:820px;
  display:flex;
  align-items:center;
  gap:14px;
  justify-content:center;
  flex-direction:column;
}
.inputRow{
  width:100%;
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
}
#input{
  width:100%;
  max-width:720px;
  box-sizing:border-box;
  padding:14px 64px 14px 16px;
  border-radius:14px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.04);
  color:var(--hud-text);
  font-size:18px;
  outline:none;
  caret-color: var(--orange);
  text-align:center;
}

/* center mic button â€” orange outline variant the user asked for */
#centerMic{
  position:absolute;
  right:12px;
  width:46px;
  height:46px;
  min-width:46px;
  border-radius:10px;
  border:2px solid rgba(255,122,48,0.14);
  background: linear-gradient(180deg, rgba(255,122,48,0.12), rgba(255,122,48,0.06));
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:18px;
  color:var(--orange);
  cursor:pointer;
  transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
  box-shadow: 0 8px 22px rgba(0,0,0,0.6);
  -webkit-tap-highlight-color: transparent;
}
#centerMic:active{ transform: translateY(1px) scale(0.995); }
#centerMic.on{
  box-shadow: inset 0 0 0 3px rgba(255,122,48,0.12), 0 10px 26px rgba(255,122,48,0.06);
  background: linear-gradient(180deg, rgba(255,122,48,0.18), rgba(255,122,48,0.08));
  color: #fff;
}

/* helper text under input */
#helper { font-size:13px; color: rgba(255,255,255,0.22); text-align:center; margin-top:8px; min-height:18px; }

/* HUD (top-right) â€” kept but made compact & responsive */
#hudShell{
  position: fixed;
  top: 18px;
  right: 14px;
  z-index: 1100;
  display:grid;
  gap:10px;
  padding:12px;
  min-width: 260px;
  text-align:center;
  color: var(--hud-text);
  background: var(--hud-glass);
  border-radius: 12px;
  border: 1px solid var(--hud-border-light);
  box-shadow: var(--hud-shadow);
  backdrop-filter: blur(10px) saturate(1.1);
  -webkit-backdrop-filter: blur(10px) saturate(1.1);
}
#hudHeader{ font-size:14px; margin:0; color:var(--hud-text); font-weight:600; }
.hud-row{ display:flex; gap:8px; }
.hud-btn{
  flex:1; font:inherit; font-size:14px; cursor:pointer;
  color:var(--hud-text); background: var(--btn-bg);
  border:1px solid rgba(255,255,255,0.03);
  border-radius:10px; padding:8px 10px;
  transition: all .12s ease; box-shadow: inset 1px 1px 2px var(--btn-inset-light);
}
.hud-btn:active{ transform: translateY(1px); }
.hud-btn.on{
  background: linear-gradient(180deg, rgba(255,122,48,0.12), rgba(255,122,48,0.06));
  color: #fff; border-color: rgba(255,122,48,0.22);
  box-shadow: 0 8px 20px rgba(255,122,48,0.06), inset 0 0 0 2px rgba(255,122,48,0.06);
}

/* Ticker (bottom-left) */
#ticker{
  position: fixed; left: 14px; bottom: 14px; z-index: 900;
  width: 46vw; max-width: 700px;
  display: flex; flex-direction: column-reverse; gap:6px;
  pointer-events: none; font-family: monospace; font-size:18px; line-height:1.3;
}
.tline{ background: rgba(255,255,255,0.02); padding:8px 10px; border-left:4px solid var(--orange); border-radius:6px; color:var(--hud-text); opacity:0.98; animation: fadeIn .5s ease; }
.user{ color: #9fd7ff; font-weight:600; }
.sys{ color: var(--orange); font-weight:700; font-size:20px; }
.note{ color: rgba(255,255,255,0.26); font-weight:300; font-size:14px; }

@keyframes fadeIn { from{opacity:0; transform:translateY(8px);} to{opacity:1; transform:none;} }

/* responsive tweaks */
@media (max-width:720px){
  #hudShell{ right:10px; top:10px; min-width:200px; padding:8px; }
  #input{ max-width:88vw; font-size:16px; padding-right:56px; }
  #centerMic{ right:8px; width:42px; height:42px; border-radius:8px; }
  #ticker{ width:74vw; font-size:15px; left:8px; bottom:10px; }
  .hud-btn{ font-size:13px; padding:8px 6px; }
}

/* preserve hidden Bloople anchors from display (same as before) */
body > a, body > b, body > h1, body > p { display:none !important; }
#rssSource, #rssSource * { display:none !important; }

</style>
</head>
<body>

<!-- Centered prompt -->
<div id="centerWrap" aria-live="polite">
  <div class="centerCard" role="region" aria-label="Centered prompt">
    <div class="inputRow">
      <input id="input" placeholder="speak or typeâ€¦ then Enter" autocomplete="off" />
      <button id="centerMic" title="Start/Stop mic">ğŸ™ï¸</button>
    </div>
    <div id="helper">Tap the orange mic or press Enter to submit â€” spoken words will be read back.</div>
  </div>
</div>

<!-- Compact HUD (top-right) -->
<div id="hudShell" aria-hidden="false">
  <div id="hudHeader">Semantic Feed â€” BBC Reactive</div>
  <input id="input_hidden_for_hud" style="display:none" />
  <div class="hud-row">
    <button id="btnMic"  class="hud-btn" title="Start/Stop mic">ğŸ™ï¸</button>
    <button id="btnMute" class="hud-btn on" title="Toggle spoken replies">ğŸ”Š</button>
    <button id="btnNext" class="hud-btn" title="Next HUD">â¡</button>
  </div>
</div>

<!-- Ticker -->
<div id="ticker" aria-live="polite" role="status"></div>

<!-- ===== BBC via Bloople (no CORS) ===== -->
<div id="rssSource" style="display:none;"></div>
<script src="//rss.bloople.net/?url=https%3A%2F%2Ffeeds.bbci.co.uk%2Fnews%2Fworld%2Frss.xml&showtitle=false&type=js"></script>

<script>
/* =========================================================
v2.1 â€” Semantic Core + Reactive BBC Blender
Modified for:
 - responsive centered input
 - orange center mic with outline (mirrors HUD mic)
 - HUD kept compact and functional (btnMic, btnMute, btnNext still wired)
All original functionality preserved.
*/

// ---------- Voice engine warm-up ----------
speechSynthesis.cancel(); // clears stale speech queue on reload

// ---------- DOM refs ----------
const input = document.getElementById('input');
const centerMic = document.getElementById('centerMic');
const btnMic = document.getElementById('btnMic');
const btnMute = document.getElementById('btnMute');
const btnNext = document.getElementById('btnNext');
const ticker = document.getElementById('ticker');

// helper to mirror hud mic class to center mic so visual state stays in sync
function mirrorMicState(){
  if(btnMic.classList.contains('on')) centerMic.classList.add('on');
  else centerMic.classList.remove('on');
}
// observe class changes on btnMic
const micObserver = new MutationObserver(muts=>{
  for(const m of muts){
    if(m.attributeName === 'class') mirrorMicState();
  }
});
micObserver.observe(btnMic, { attributes: true, attributeFilter: ['class'] });

// ensure clicking the center button triggers the HUD mic behavior (wires into existing listeners)
centerMic.addEventListener('click', ()=>{ btnMic.click(); });

// ---------- Ticker ----------
function addLine(text, cls='sys'){
  const el = document.createElement('div');
  el.className = `tline ${cls}`;
  el.textContent = text;
  ticker.prepend(el);
  if(ticker.children.length > 80) ticker.removeChild(ticker.lastChild);
}
addLine('v2.1 online â€” semantic core + BBC reactive blending', 'note');
addLine('Mic optional. Typing always works. Say: "time?", "repeat after me â€¦", or anything.', 'note');

// ---------- Speech Synthesis (reply) ----------
let speakEnabled = true;
let voicesReady = false;
function waitVoices(){
  return new Promise(res=>{
    const id = setInterval(()=>{
      if (speechSynthesis.getVoices().length){ clearInterval(id); voicesReady=true; res(); }
    }, 100);
    setTimeout(()=>{ if(!voicesReady){ clearInterval(id); voicesReady=true; res(); } }, 3500);
  });
}
async function speak(text){
  if(!speakEnabled || !('speechSynthesis' in window)) return;
  if(!voicesReady) await waitVoices();
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-GB';
  u.rate = 1.02; u.pitch = 0.95; u.volume = 0.9;
  const v = speechSynthesis.getVoices();
  u.voice = v.find(x => /en-GB|UK|Kate|Samantha|Google UK English/i.test(x.name)) || v[0];
  try{ speechSynthesis.speak(u); }catch(e){ /* ignore */ }
}

// wire mute (keeps original behavior)
btnMute.addEventListener('click', ()=>{
  speakEnabled = !speakEnabled;
  btnMute.classList.toggle('on', speakEnabled);
  btnMute.textContent = speakEnabled ? 'ğŸ”Š Voice On' : 'ğŸ”‡ Voice Off';
  addLine(`Spoken replies ${speakEnabled?'enabled':'disabled'}`, 'note');
});

// iOS/WebKit needs a user action before speaking reliably
window.addEventListener('touchstart', ()=> { try { speechSynthesis.speak(new SpeechSynthesisUtterance('')); } catch(_){} }, { once:true });

// ---------- BBC feed buffer (via Bloople injecting anchors) ----------
let feedBuffer = [];   // array of {title, ts}
function harvestHeadlines(){
  // Bloople injects into <body>; select anchors and dedupe by text
  const anchors = Array.from(document.body.querySelectorAll('a'));
  const titles = anchors.map(a => (a.textContent || '').trim()).filter(Boolean);
  const now = Date.now();
  titles.forEach(t => {
    if(!feedBuffer.some(x => x.title === t)){
      feedBuffer.push({ title: t, ts: now });
    }
  });
  if(feedBuffer.length > 80) feedBuffer = feedBuffer.slice(-80);
}
setTimeout(harvestHeadlines, 1500);
setInterval(harvestHeadlines, 60000);

// ensure feed anchors inert and styled (non-intrusive)
setTimeout(() => {
  document.querySelectorAll('a').forEach(a => {
    a.removeAttribute('href');
    a.style.color = 'rgba(150,200,255,0.4)';
    a.style.pointerEvents = 'none';
    a.style.textDecoration = 'none';
  });
}, 3000);

// ---------- Tiny keyword helper ----------
function keywordsFrom(text){
  return (text.toLowerCase()
    .replace(/[^a-z0-9\s]/g,' ')
    .split(/\s+/)
    .filter(w => w.length > 3 && !'about with into from that this what your have just will been they them than then here there which where only also because while after before could would should doing being hello thank'.includes(w))
  );
}

// ---------- Blend user text with BBC headlines ----------
function blendWithFeed(userText){
  if(feedBuffer.length === 0) return null;
  const keys = keywordsFrom(userText);
  let candidates = [];

  if(keys.length){
    candidates = feedBuffer
      .map(h => {
        const score = keys.reduce((s,k)=> s + (h.title.toLowerCase().includes(k) ? 1 : 0), 0);
        return { ...h, score };
      })
      .filter(x => x.score > 0)
      .sort((a,b) => b.score - a.score);
  }
  if(candidates.length === 0){
    const pool = feedBuffer.slice(-20);
    for(let i=0;i<3 && pool.length;i++){
      const idx = Math.floor(Math.random()*pool.length);
      candidates.push(pool.splice(idx,1)[0]);
    }
  }

  const pick = (arr, n) => {
    const out = [];
    const copy = arr.slice();
    while(n-- > 0 && copy.length){
      out.push(copy.splice(Math.floor(Math.random()*copy.length),1)[0]);
    }
    return out;
  };

  const chosen = pick(candidates, 2).map(x => x.title);
  const stems = ['signal echoes:','semantic crossover:','field resonance:','adjacent headline:','network murmur:','latent alignment:'];
  const stem = stems[Math.floor(Math.random()*stems.length)];

  if(chosen.length === 1) return `${stem} ${chosen[0]}`;
  if(chosen.length === 2){
    const [a,b] = chosen;
    const A = a.replace(/[â€“â€”-]\s.*$/,'').replace(/\.$/,'');
    const B = b.replace(/^[A-Z].{0,10}:\s*/,'');
    return `${stem} ${A} â€” ${B}.`;
  }
  return 'channel quiet.';
}

// ---------- Semantic router (same public behavior) ----------
function semanticRouter(raw){
  const text = (raw||'').trim();
  if(!text) return;
  addLine('> ' + text, 'user');

  const lower = text.toLowerCase();
  if (lower === 'hello' || lower.startsWith('hi')) {
    const reply = "Hello. I'm listening.";
    addLine(reply, 'sys'); speak(reply);
  } else if (lower.includes('time')) {
    const reply = 'Current time: ' + new Date().toLocaleTimeString();
    addLine(reply, 'sys'); speak(reply);
  } else if (lower.startsWith('repeat after me')) {
    const say = text.replace(/^repeat after me/i, '').trim() || 'â€¦say what?';
    addLine(say, 'sys'); speak(say);
  } else {
    const echo = 'You said: ' + text;
    addLine(echo, 'sys'); speak(echo);
  }

  const blend = blendWithFeed(text);
  if(blend){
    setTimeout(()=>{ addLine(blend, 'sys'); speak(blend); }, 520);
  }
}

// ---------- Input (text) wiring ----------
input.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    e.preventDefault();
    const v = input.value.trim();
    if(v){ semanticRouter(v); input.value = ''; }
  }
});
setTimeout(()=> input.focus(), 250);

// ---------- Voice input (unchanged logic) ----------
let rec = null, listening = false;
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
if (!SR) {
  btnMic.addEventListener('click', ()=>{
    addLine('Mic recognition not available on this browser. Typing still works.', 'note');
    // quick flash of center mic to show feedback
    centerMic.classList.add('on');
    setTimeout(()=> centerMic.classList.remove('on'), 500);
  });
} else {
  rec = new SR();
  rec.lang = 'en-US';
  rec.interimResults = true;
  rec.continuous = true;

  rec.onstart = () => { listening = true; btnMic.classList.add('on'); addLine('ğŸ™ï¸ Voice capture started', 'note'); };
  rec.onend   = () => { listening = false; btnMic.classList.remove('on'); addLine('â¹ï¸ Voice capture stopped', 'note'); };

  rec.onresult = (evt)=>{
    let finalChunk = '';
    for (let i = evt.resultIndex; i < evt.results.length; i++) {
      const t = evt.results[i][0].transcript;
      if (evt.results[i].isFinal) finalChunk += t;
    }
    if (finalChunk) {
      input.value = finalChunk;
      semanticRouter(finalChunk);
    }
  };
  rec.onerror = (e)=>{ addLine('Voice error: ' + (e && e.error? e.error : e), 'note'); };

  btnMic.addEventListener('click', ()=>{
    try{ if(!listening){ rec.start(); } else { rec.stop(); } }
    catch(err){ addLine('Mic error: ' + (err.message||err), 'note'); }
  });
}

// clicking centerMic triggers the same behavior (already wired above to btnMic.click())

// ---------- Mode Shift (unchanged) ----------
btnNext.addEventListener('click', () => {
  addLine('Mode shift â†’ entering Scene 2: Video environment', 'note');
  speak('Switching mode');
  setTimeout(() => {
    window.location.href = 'video_scene2_.html';
  }, 800);
});

// ---------- First pulse ----------
setTimeout(()=> addLine('BBC headlines linked. Waiting for your inputâ€¦', 'note'), 1200);

</script>
</body>
</html>
