<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BBC two</title>

<style>
:root{
  --hud-glass: rgba(185, 225, 255, 0.18);
  --hud-border-light: rgba(255, 255, 255, 0.22);
  --hud-border-dark: rgba(0, 45, 90, 0.06);
  --hud-shadow: 0 12px 45px rgba(0, 50, 90, 0.25);
  --hud-text: #dfffe6;
  --btn-bg: rgba(255,255,255,0.04);
  --btn-inset-light: rgba(255,255,255,0.06);
  --btn-inset-dark: rgba(0,30,60,0.06);
  --bg: #000000;
  --ticker: #ff3a2f;
  --orange: #ff7a30;
}

/* page background */
html,body{height:100%;margin:0;background:var(--bg);color:var(--hud-text);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}

/* centered minimalist prompt area (responsive) */
#centerWrap{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  box-sizing:border-box;
  pointer-events: none;
}
.centerCard{
  pointer-events:auto;
  width:min(920px,96vw);
  max-width:920px;
  display:flex;
  align-items:center;
  gap:14px;
  justify-content:center;
  flex-direction:column;
}
.inputRow{
  width:100%;
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* BLUR BOX INPUT (translucent, rounded, clarifies itself over layers) */
#input{
  width:100%;
  max-width:820px;
  box-sizing:border-box;
  padding:18px 72px 18px 18px;     /* larger touch target and room for mic */
  border-radius:16px;
  background: rgba(255,255,255,0.04);            /* subtle light glass */
  border: 1px solid rgba(255,255,255,0.06);
  color:var(--hud-text);
  font-size:20px;                  /* increased font size for friendliness */
  line-height:1.2;
  outline:none;
  caret-color: var(--orange);
  text-align:center;
  min-height:56px;                 /* taller input to be more touch friendly */
  -webkit-appearance: none;
  /* translucent blur effect (the "blur box" you referenced) */
  backdrop-filter: blur(8px) saturate(1.05);
  -webkit-backdrop-filter: blur(8px) saturate(1.05);
  box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
}

/* center mic button â€” orange outline variant */
#centerMic{
  position:absolute;
  right:12px;
  width:52px;
  height:52px;
  min-width:52px;
  border-radius:12px;
  border:2px solid rgba(255,122,48,0.14);
  background: linear-gradient(180deg, rgba(255,122,48,0.10), rgba(255,122,48,0.04));
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:20px;
  color:var(--orange);
  cursor:pointer;
  transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
  box-shadow: 0 8px 22px rgba(0,0,0,0.6);
  -webkit-tap-highlight-color: transparent;
}
#centerMic:active{ transform: translateY(1px) scale(0.995); }
#centerMic.on{
  box-shadow: inset 0 0 0 3px rgba(255,122,48,0.12), 0 10px 26px rgba(255,122,48,0.06);
  background: linear-gradient(180deg, rgba(255,122,48,0.18), rgba(255,122,48,0.08));
  color: #fff;
}

/* helper text under input */
#helper { font-size:14px; color: rgba(255,255,255,0.22); text-align:center; margin-top:8px; min-height:18px; }

/* compact HUD (top-right) */
#hudShell{
  position: fixed;
  top: 14px;
  right: 10px;
  z-index: 1100;
  display:grid;
  gap:8px;
  padding:10px;
  min-width: 220px;
  text-align:center;
  color: var(--hud-text);
  background: var(--hud-glass);
  border-radius: 12px;
  border: 1px solid var(--hud-border-light);
  box-shadow: var(--hud-shadow);
  backdrop-filter: blur(10px) saturate(1.1);
  -webkit-backdrop-filter: blur(10px) saturate(1.1);
}
#hudHeader{ font-size:13px; margin:0; color:var(--hud-text); font-weight:600; }
.hud-row{ display:flex; gap:8px; }
.hud-btn{
  flex:1; font:inherit; font-size:13px; cursor:pointer;
  color:var(--hud-text); background: var(--btn-bg);
  border:1px solid rgba(255,255,255,0.03);
  border-radius:10px; padding:8px 10px;
  transition: all .12s ease; box-shadow: inset 1px 1px 2px var(--btn-inset-light);
}
.hud-btn:active{ transform: translateY(1px); }
.hud-btn.on{
  background: linear-gradient(180deg, rgba(255,122,48,0.12), rgba(255,122,48,0.06));
  color: #fff; border-color: rgba(255,122,48,0.22);
  box-shadow: 0 8px 20px rgba(255,122,48,0.06), inset 0 0 0 2px rgba(255,122,48,0.06);
}

/* Ticker (bottom-left) */
#ticker{
  position: fixed; left: 12px; bottom: 12px; z-index: 900;
  width: 46vw; max-width: 700px;
  display: flex; flex-direction: column-reverse; gap:6px;
  pointer-events: none; font-family: monospace; font-size:18px; line-height:1.3;
}
.tline{ background: rgba(255,255,255,0.02); padding:8px 10px; border-left:4px solid var(--orange); border-radius:6px; color:var(--hud-text); opacity:0.98; animation: fadeIn .5s ease; }
.user{ color: #9fd7ff; font-weight:600; }
.sys{ color: var(--orange); font-weight:700; font-size:20px; }
.note{ color: rgba(255,255,255,0.26); font-weight:300; font-size:14px; }

@keyframes fadeIn { from{opacity:0; transform:translateY(8px);} to{opacity:1; transform:none;} }

/* responsive tweaks */
@media (max-width:720px){
  #hudShell{ right:8px; top:8px; min-width:180px; padding:8px; }
  #input{ max-width:88vw; font-size:18px; padding-right:56px; }
  #centerMic{ right:8px; width:46px; height:46px; border-radius:10px; font-size:18px; }
  #ticker{ width:74vw; font-size:15px; left:8px; bottom:8px; }
  .hud-btn{ font-size:12px; padding:8px 6px; }
}

/* preserve hidden Bloople anchors from display (same as before) */
body > a, body > b, body > h1, body > p { display:none !important; }
#rssSource, #rssSource * { display:none !important; }
</style>
</head>
<body>

<!-- Centered prompt -->
<div id="centerWrap" aria-live="polite">
  <div class="centerCard" role="region" aria-label="Centered prompt">
    <div class="inputRow">
      <input id="input" placeholder="speak or typeâ€¦ then Enter" autocomplete="off" aria-label="Prompt input" />
      <button id="centerMic" title="Start/Stop mic" aria-pressed="false">ğŸ™ï¸</button>
    </div>
    <div id="helper">Tap the orange mic or press Enter to submit â€” spoken words will be read back.</div>
  </div>
</div>

<!-- Compact HUD (top-right) -->
<div id="hudShell" aria-hidden="false">
  <div id="hudHeader">Semantic Feed â€” BBC Reactive</div>
  <div class="hud-row">
    <button id="btnMic"  class="hud-btn" title="Start/Stop mic">ğŸ™ï¸</button>
    <button id="btnMute" class="hud-btn on" title="Toggle spoken replies">ğŸ”Š</button>
    <button id="btnNext" class="hud-btn" title="Next HUD (disabled)">â¡</button>
  </div>
</div>

<!-- Ticker -->
<div id="ticker" aria-live="polite" role="status"></div>

<!-- ===== BBC via Bloople (no CORS) ===== -->
<div id="rssSource" style="display:none;"></div>
<script src="//rss.bloople.net/?url=https%3A%2F%2Ffeeds.bbci.co.uk%2Fnews%2Fworld%2Frss.xml&showtitle=false&type=js"></script>

<script>
/* =========================================================
v2.1 â€” Semantic Core + Reactive BBC Blender
This file preserves all original logic but:
 - larger, friendlier blur-box input (visually translucent with backdrop blur)
 - center orange mic mirrors HUD mic and triggers the same handlers
 - HUD "Next" button kept visible but navigation link is commented out (disabled)
*/

// ---------- Voice engine warm-up ----------
speechSynthesis.cancel();

// ---------- DOM refs ----------
const input = document.getElementById('input');
const centerMic = document.getElementById('centerMic');
const btnMic = document.getElementById('btnMic');
const btnMute = document.getElementById('btnMute');
const btnNext = document.getElementById('btnNext');
const ticker = document.getElementById('ticker');
const helper = document.getElementById('helper');

// ---------- helper: ticker ----------
function addLine(text, cls='sys'){
  const el = document.createElement('div');
  el.className = `tline ${cls}`;
  el.textContent = text;
  ticker.prepend(el);
  if(ticker.children.length > 80) ticker.removeChild(ticker.lastChild);
}
addLine('v2.1 online â€” semantic core + BBC reactive blending', 'note');
addLine('Mic optional. Typing always works. Say: "time?", "repeat after me â€¦", or anything.', 'note');

// ---------- Speech Synthesis ----------
let speakEnabled = true;
let voicesReady = false;
function waitVoices(){
  return new Promise(res=>{
    const id = setInterval(()=>{
      if (speechSynthesis.getVoices().length){ clearInterval(id); voicesReady=true; res(); }
    }, 100);
    setTimeout(()=>{ if(!voicesReady){ clearInterval(id); voicesReady=true; res(); } }, 3500);
  });
}
async function speak(text){
  if(!speakEnabled || !('speechSynthesis' in window)) return;
  if(!voicesReady) await waitVoices();
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-GB';
  u.rate = 1.02; u.pitch = 0.95; u.volume = 0.9;
  const v = speechSynthesis.getVoices();
  u.voice = v.find(x => /en-GB|UK|Kate|Samantha|Google UK English/i.test(x.name)) || v[0];
  try{ speechSynthesis.speak(u); }catch(e){ /* ignore */ }
}

// wire mute
btnMute.addEventListener('click', ()=>{
  speakEnabled = !speakEnabled;
  btnMute.classList.toggle('on', speakEnabled);
  btnMute.textContent = speakEnabled ? 'ğŸ”Š Voice On' : 'ğŸ”‡ Voice Off';
  addLine(`Spoken replies ${speakEnabled?'enabled':'disabled'}`, 'note');
});

// Warm up TTS on touch (iOS)
window.addEventListener('touchstart', ()=> { try { speechSynthesis.speak(new SpeechSynthesisUtterance('')); } catch(_){} }, { once:true });

// ---------- Feed harvesting (unchanged logic) ----------
let feedBuffer = [];
function harvestHeadlines(){
  const anchors = Array.from(document.body.querySelectorAll('a'));
  const titles = anchors.map(a => (a.textContent || '').trim()).filter(Boolean);
  const now = Date.now();
  titles.forEach(t => {
    if(!feedBuffer.some(x => x.title === t)){
      feedBuffer.push({ title: t, ts: now });
    }
  });
  if(feedBuffer.length > 80) feedBuffer = feedBuffer.slice(-80);
}
setTimeout(harvestHeadlines, 1500);
setInterval(harvestHeadlines, 60000);
setTimeout(() => {
  document.querySelectorAll('a').forEach(a => {
    a.removeAttribute('href');
    a.style.color = 'rgba(150,200,255,0.4)';
    a.style.pointerEvents = 'none';
    a.style.textDecoration = 'none';
  });
}, 3000);

// ---------- small helpers ----------
function keywordsFrom(text){
  return (text.toLowerCase()
    .replace(/[^a-z0-9\s]/g,' ')
    .split(/\s+/)
    .filter(w => w.length > 3 && !'about with into from that this what your have just will been they them than then here there which where only also because while after before could would should doing being hello thank'.includes(w))
  );
}

function blendWithFeed(userText){
  if(feedBuffer.length === 0) return null;
  const keys = keywordsFrom(userText);
  let candidates = [];
  if(keys.length){
    candidates = feedBuffer
      .map(h => {
        const score = keys.reduce((s,k)=> s + (h.title.toLowerCase().includes(k) ? 1 : 0), 0);
        return { ...h, score };
      })
      .filter(x => x.score > 0)
      .sort((a,b) => b.score - a.score);
  }
  if(candidates.length === 0){
    const pool = feedBuffer.slice(-20);
    for(let i=0;i<3 && pool.length;i++){
      const idx = Math.floor(Math.random()*pool.length);
      candidates.push(pool.splice(idx,1)[0]);
    }
  }
  const pick = (arr, n) => {
    const out = [];
    const copy = arr.slice();
    while(n-- > 0 && copy.length){
      out.push(copy.splice(Math.floor(Math.random()*copy.length),1)[0]);
    }
    return out;
  };
  const chosen = pick(candidates, 2).map(x => x.title);
  const stems = ['signal echoes:','semantic crossover:','field resonance:','adjacent headline:','network murmur:','latent alignment:'];
  const stem = stems[Math.floor(Math.random()*stems.length)];
  if(chosen.length === 1) return `${stem} ${chosen[0]}`;
  if(chosen.length === 2){
    const [a,b] = chosen;
    const A = a.replace(/[â€“â€”-]\s.*$/,'').replace(/\.$/,'');
    const B = b.replace(/^[A-Z].{0,10}:\s*/,'');
    return `${stem} ${A} â€” ${B}.`;
  }
  return 'channel quiet.';
}

// ---------- Semantic router ----------
function semanticRouter(raw){
  const text = (raw||'').trim();
  if(!text) return;
  addLine('> ' + text, 'user');

  const lower = text.toLowerCase();
  if (lower === 'hello' || lower.startsWith('hi')) {
    const reply = "Hello. I'm listening.";
    addLine(reply, 'sys'); speak(reply);
  } else if (lower.includes('time')) {
    const reply = 'Current time: ' + new Date().toLocaleTimeString();
    addLine(reply, 'sys'); speak(reply);
  } else if (lower.startsWith('repeat after me')) {
    const say = text.replace(/^repeat after me/i, '').trim() || 'â€¦say what?';
    addLine(say, 'sys'); speak(say);
  } else {
    const echo = 'You said: ' + text;
    addLine(echo, 'sys'); speak(echo);
  }

  const blend = blendWithFeed(text);
  if(blend){
    setTimeout(()=>{ addLine(blend, 'sys'); speak(blend); }, 520);
  }
}

// ---------- Input wiring ----------
input.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    e.preventDefault();
    const v = input.value.trim();
    if(v){ semanticRouter(v); input.value = ''; }
  }
});
setTimeout(()=> input.focus(), 250);

// ---------- Speech recognition: improved behavior so STT populates the input ----------
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
let rec = null, listening = false;
if (!SR) {
  // Fallback: flash mic and show note
  btnMic.addEventListener('click', ()=>{
    addLine('Mic recognition not available on this browser. Typing still works.', 'note');
    centerMic.classList.add('on');
    setTimeout(()=> centerMic.classList.remove('on'), 600);
  });
  centerMic.addEventListener('click', ()=> btnMic.click());
} else {
  rec = new SR();
  rec.lang = 'en-US';
  rec.interimResults = true;   // show partial transcripts as they arrive
  rec.continuous = true;       // keep listening in continuous mode unless stopped

  // Ensure mic visual state is mirrored between HUD and center control
  function setMicOn(on){
    if(on){
      btnMic.classList.add('on');
      centerMic.classList.add('on');
      centerMic.setAttribute('aria-pressed','true');
    }else{
      btnMic.classList.remove('on');
      centerMic.classList.remove('on');
      centerMic.setAttribute('aria-pressed','false');
    }
  }

  rec.onstart = () => { listening = true; setMicOn(true); addLine('ğŸ™ï¸ Voice capture started', 'note'); helper && (helper.textContent = 'Listeningâ€¦'); };
  rec.onend   = () => { listening = false; setMicOn(false); addLine('â¹ï¸ Voice capture stopped', 'note'); helper && (helper.textContent = 'Tap the orange mic or press Enter'); };

  rec.onresult = (evt) => {
    // Build interim and final transcripts, update the visible centered input live.
    let interim = '';
    let final = '';
    for (let i = evt.resultIndex; i < evt.results.length; ++i) {
      const res = evt.results[i];
      const t = res[0].transcript;
      if (res.isFinal) final += t;
      else interim += t;
    }

    // Prefer final when present, otherwise show interim
    const display = (final || interim).trim();
    if(display){
      input.value = display;
      try{ input.focus(); input.setSelectionRange(input.value.length, input.value.length); }catch(e){}
    }

    // If we received a final chunk, route it immediately and clear the input
    if(final && final.trim()){
      const f = final.trim();
      semanticRouter(f);
      input.value = '';
    }
  };

  rec.onerror = (e) => {
    addLine('Voice error: ' + (e && e.error ? e.error : String(e)), 'note');
    helper && (helper.textContent = 'Voice error â€” try again or type.');
  };

  // Wire HUD mic to control recognition start/stop
  btnMic.addEventListener('click', ()=>{
    try{
      if(!listening){ rec.start(); } else { rec.stop(); }
    }catch(err){
      addLine('Mic error: ' + (err && err.message ? err.message : String(err)), 'note');
    }
  });
  // Center mic triggers same action
  centerMic.addEventListener('click', ()=> { btnMic.click(); });
}

// ---------- Mode Shift (disabled navigation) ----------
btnNext.addEventListener('click', () => {
  addLine('Mode shift requested â€” navigation disabled in this build.', 'note');
  speak('Mode shift is currently disabled.');
  // The original navigation is intentionally commented out so the icon remains but the ARF/link is disabled.
  /*
  setTimeout(() => {
    window.location.href = 'video_scene2_.html';
  }, 800);
  */
});

// ---------- First pulse ----------
setTimeout(()=> addLine('BBC headlines linked. Waiting for your inputâ€¦', 'note'), 1200);
</script>
</body>
</html>
