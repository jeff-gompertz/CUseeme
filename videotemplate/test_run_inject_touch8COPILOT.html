<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CUSeeMe Modular v1.7 ‚Äî HUD Toggle Demo (Clean & Fixed)</title>
  <style>
    :root {
      --hud-glass: rgba(255, 225, 255, 0.45);
      --hud-border-light: rgba(255, 255, 255, 0.65);
      --hud-border-dark: rgba(0, 45, 90, 0.35);
      --hud-shadow: 0 12px 45px rgba(0, 50, 90, 0.35);
      --hud-text: #1b1d22;
      --btn-bg: rgba(215, 235, 255, 0.35);
      --btn-inset-light: rgba(255,255,255,0.8);
      --btn-inset-dark: rgba(0,30,60,0.3);
      --btn-glow: rgba(255,120,50,0.7);
      --btn-glow-outer: rgba(255,150,80,0.35);
      --background: transparent;
      --ticker: #ff3a2f;

      /* advance button defaults (customize if needed) */
      --ab-bg-start: rgba(255,255,255,0.98);
      --ab-bg-end:   rgba(240,250,240,0.92);
      --ab-fore:     #132030;
      --ab-progress: linear-gradient(90deg, rgba(255,74,74,0.14), rgba(255,120,40,0.08));
    }

    html,body{
      height:100%; margin:0;
      background: var(--background);
      font-family: "VT323", ui-monospace, Menlo, Consolas, monospace;
      color:#222;
      overflow:visible;
    }
    #bgVideo { position: fixed; top:0; left:0; width:100vw; height:100vh; object-fit:cover; z-index:-2; pointer-events:none; }

    #hudIndex{ position:absolute; top:6px; left:10px; font-size:12px; opacity:.55; }
    .hud-row{ display:flex; gap:12px; justify-content:space-between; }
    .hud-btn{
      flex:1; font-family:"VT323", monospace; font-size:17px; color:#132030;
      background:var(--btn-bg); border:none; border-radius:10px;
      box-shadow: inset 1px 1px 2px var(--btn-inset-light), inset -1px -2px 3px var(--btn-inset-dark), 0 3px 6px rgba(0,0,0,0.08);
      padding:10px 12px; cursor:pointer; transition:all .22s ease;
    }
    .hud-btn:hover{ transform:translateY(-1px); box-shadow:0 5px 12px rgba(0,0,0,0.15); }
    .hud-btn.active{ background:rgba(255,165,100,0.15); color:#ff6a2f; font-weight:600; box-shadow: inset 0 0 4px var(--btn-glow), 0 0 14px 3px var(--btn-glow-outer), 0 2px 8px rgba(0,0,0,0.2); }

    .hud-panel { position: relative; opacity: 1; pointer-events: auto; transition: opacity .3s ease; }
    .hud-panel:not(.active) { opacity: 0.8; }
    #ticker{
      position:fixed; left:16px; bottom:14px; z-index:900;
      width:45vw; max-width:700px; max-height:50vh;
      display:flex; flex-direction:column-reverse; overflow:hidden;
      color:var(--ticker); font-size:18px; line-height:1.25;
    }
    .tline{ opacity:.95; margin:0; animation:fadeIn .6s ease; }
    @keyframes fadeIn{ from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:none} }

    .miniWin{
      position:absolute; width:66vw; max-width:380px; aspect-ratio:9/12;
      background:rgba(210,240,255,0.25); border:1px solid rgba(255,255,255,0.55);
      border-radius:16px; backdrop-filter:blur(12px);
      box-shadow: inset 0 1px 2px rgba(255,255,255,0.6), 0 18px 40px rgba(0,0,0,0.25);
      overflow:hidden; cursor:grab; z-index:500;
    }
    .miniWin:active{ cursor:grabbing; }
    .miniBar{ display:flex; align-items:center; justify-content:space-between; padding:4px 10px; height:26px; background:rgba(255,255,255,0.18); font-size:12px; color:#222; user-select:none; }
    .miniInner{ position:relative; width:100%; height:calc(100% - 26px); }
    .miniVideo{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); background:black; }

    @media (max-width:700px){
      .miniWin{ left:4vw !important; right:auto !important; max-width:90vw !important; width:90vw !important; }
    }

    /* advance button styling kept minimal here (full CSS used below) */
  </style>
</head>
<body>
  <!-- Background video -->
  <video id="bgVideo" autoplay muted loop playsinline>
    <source src="/CUseeme/media/VideoObject.mp4" type="video/mp4" />
  </video>
  <video id="cameraMain" autoplay muted playsinline style="display:none"></video>

  <!-- HUD -->
  <div id="hudWrapper">
    <div id="hudIndex">1 of 2</div>
    <div id="hudShell">
      <div id="hudHeader">2 of 2</div>
      <div id="hud1" class="hud-panel active">
        <div class="hud-row">
          <button class="hud-btn" id="btnSpawn5">‚ûï Spawn 5</button>
          <button class="hud-btn" id="btnReverseCam">üîÅ Reverse Cam</button>
        </div>
        <div class="hud-row">
          <button class="hud-btn" id="btnCloseAll">‚úï Close All</button>
        </div>
      </div>
    </div>
  </div>

  <div id="ticker" aria-live="polite"></div>

  <!-- MAIN SCRIPT: spawn system, HUD wiring, safe DOMContentLoaded usage -->
  <script>
    // Diagnostics ticker helper
    const ticker = document.getElementById('ticker');
    function addTicker(txt){
      const d = document.createElement('div'); d.className='tline'; d.textContent = txt;
      ticker.prepend(d); while(ticker.children.length>80) ticker.removeChild(ticker.lastChild);
    }
    ['index: v1.7 mode dynamic','retro4.4 aqua loaded','HUD ready','multi-HUD active'].forEach((m,i)=>setTimeout(()=>addTicker(m),250*i));

    // Config
    const USE_LIVE_CAMERA = false;
    const BG_VIDEO_FILENAME = "/CUseeme/media/VideoObject.mp4";

    // Camera
    let mediaStream = null;
    let facing = 'environment';
    async function initStream(){
      if(!USE_LIVE_CAMERA) return;
      if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
      try{
        mediaStream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:facing } }, audio:false });
        addTicker(`camera: ${facing==='user'?'front':'rear'} feed ready`);
        document.querySelectorAll('.miniVideo').forEach(v=>{
          try { v.srcObject = mediaStream; }catch(e){}
        });
      }catch(e){
        addTicker('‚ö† camera denied/unavailable');
        console.warn('initStream', e);
      }
    }

    // Mini windows
    let winCount = 0, spawnUsed = false;
    function makeMiniWindow({ x = 150, y = 300 } = {}) {
      winCount++;
      const el = document.createElement('div');
      el.className = 'miniWin';
      el.style.left = x + 'px';
      el.style.top  = y + 'px';
      el.innerHTML = `
        <div class="miniBar">
          <div class="miniTitle">subject_${String(winCount).padStart(4,'0')}</div>
          <div class="miniBtns"><div class="win-dot"></div><div class="win-dot"></div><div class="win-dot"></div></div>
        </div>
        <div class="miniInner"><video class="miniVideo" autoplay muted loop playsinline></video></div>`;
      document.body.appendChild(el);

      const v = el.querySelector('.miniVideo');
      if (USE_LIVE_CAMERA) {
        if(mediaStream) v.srcObject = mediaStream;
      } else {
        v.src = BG_VIDEO_FILENAME; v.loop = true; v.muted = true; v.autoplay = true; v.playsInline = true;
        try { v.currentTime = document.getElementById('bgVideo').currentTime; } catch(e){}
      }

      // Drag handlers
      const bar = el.querySelector('.miniBar');
      let dragging=false, sx=0, sy=0, sl=0, st=0;
      function start(e){
        dragging=true;
        const r = el.getBoundingClientRect(); sl=r.left; st=r.top;
        sx = e.touches ? e.touches[0].clientX : e.clientX;
        sy = e.touches ? e.touches[0].clientY : e.clientY;
        document.addEventListener('pointermove', move); document.addEventListener('pointerup', stop);
        document.addEventListener('touchmove', move, { passive:false }); document.addEventListener('touchend', stop);
      }
      function move(e){
        if(!dragging) return;
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        el.style.left = (sl + (cx - sx)) + 'px';
        el.style.top  = (st + (cy - sy)) + 'px';
        e.preventDefault?.();
      }
      function stop(){ dragging=false; document.removeEventListener('pointermove', move); document.removeEventListener('pointerup', stop); document.removeEventListener('touchmove', move); document.removeEventListener('touchend', stop); }
      bar.addEventListener('pointerdown', start); bar.addEventListener('touchstart', start, { passive:false });
      return el;
    }

    // Safe wiring after DOM ready
    document.addEventListener('DOMContentLoaded', function(){
      const btnSpawn5 = document.getElementById('btnSpawn5');
      const btnCloseAll = document.getElementById('btnCloseAll');
      const btnReverseCam = document.getElementById('btnReverseCam');

      if(btnSpawn5){
        btnSpawn5.addEventListener('click', ()=>{
          if(spawnUsed) return addTicker('spawn blocked: already active');
          spawnUsed = true;
          let startX = 170 + Math.random()*40, startY = 300 + Math.random()*40;
          if(window.innerWidth < 700) startX = 40;
          for(let i=0;i<5;i++) makeMiniWindow({ x: startX + i*26, y: startY + i*18 });
          addTicker('spawned 5 windows');
        });
      } else console.warn('btnSpawn5 missing');

      if(btnCloseAll){
        btnCloseAll.addEventListener('click', ()=>{
          document.querySelectorAll('.miniWin').forEach(n=>n.remove());
          winCount=0; spawnUsed=false;
          addTicker('all windows closed');
        });
      } else console.warn('btnCloseAll missing');

      if(btnReverseCam){
        btnReverseCam.addEventListener('click', async ()=>{
          facing = (facing === 'user') ? 'environment' : 'user';
          await initStream();
        });
      }

      // initial auto-spawn (runs after DOM ready)
      (async function autoSpawn(){
        await initStream();
        let startX = 100, startY = 170;
        if(window.innerWidth < 700) startX = 40;
        for(let i=0;i<5;i++) makeMiniWindow({ x: startX + i*22, y: startY + i*18 });
        addTicker('initial spawn complete (DOMContentLoaded)');
      })();
    }); // end DOMContentLoaded

    // HUD header toggle
    const huds = [...document.querySelectorAll('.hud-panel')];
    const hudIndex = document.getElementById('hudIndex');
    let currentHUD = 0;
    function updateHUDLabel(){ if(hudIndex) hudIndex.textContent = `HUD ${currentHUD+1} / ${huds.length}`; }
    function showHUD(i){
      if(!huds.length) return;
      huds[currentHUD].classList.remove('active');
      currentHUD = (i + huds.length) % huds.length;
      huds[currentHUD].classList.add('active');
      updateHUDLabel();
      addTicker(`HUD switched ‚Üí ${currentHUD+1}`);
    }
    const hdr = document.getElementById('hudHeader');
    if(hdr) hdr.addEventListener('click', ()=> showHUD(currentHUD + 1));
    updateHUDLabel();

    // end of main script
  </script>

  <!-- ADVANCE BUTTON (HTML + CSS + small behavior script) - OUTSIDE the main <script> -->
  <!-- Adjust the URL here (data-longpress-url) to change the destination -->
  <button id="advanceButtonGlobal"
          type="button"
          role="button"
          aria-pressed="false"
          title="Hold to advance"
          tabindex="0"
          data-longpress-url="https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch7.html"
          data-hold-ms="900"
          aria-label="Advance">
    <span class="ab-progress" aria-hidden="true"></span>
    <span class="ab-label">Advance</span>
  </button>

  <style>
    /* Advance button styles (kept in-document for single-file convenience) */
    #advanceButtonGlobal{
      position:fixed; right:16px; bottom:16px; z-index:10020;
      display:inline-flex; align-items:center; justify-content:center;
      height:36px; min-width:84px; padding:7px 22px; border-radius:28px;
      background: linear-gradient(180deg, var(--ab-bg-start), var(--ab-bg-end));
      color: var(--ab-fore); font-family:"VT323",monospace; font-weight:600; font-size:15px;
      cursor:pointer; user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      -webkit-tap-highlight-color:transparent; -webkit-appearance:none; appearance:none;
      touch-action:none; box-shadow:0 6px 20px rgba(0,0,0,0.15); border:1px solid rgba(255,255,255,0.06);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    #advanceButtonGlobal .ab-progress{ position:absolute; left:0; top:0; height:100%; width:0%; border-radius:inherit; pointer-events:none; z-index:0; background:var(--ab-progress); transition: width 0s linear; }
    #advanceButtonGlobal .ab-label{ position:relative; z-index:1; padding:0 6px; user-select:none; }
    #advanceButtonGlobal.holding{ transform:translateY(-1px) scale(1.01); box-shadow:0 10px 28px rgba(0,0,0,0.18); }
    #advanceButtonGlobal:focus{ outline:none; box-shadow: 0 0 0 4px rgba(0,208,255,0.12), 0 8px 22px rgba(0,0,0,0.18); }
    @media (max-width:540px){ #advanceButtonGlobal{ right:8px; bottom:8px; padding:6px 12px; min-width:64px; height:30px; font-size:12px; } }
  </style>

  <script>
    // Small, focused advance-button behavior (keeps it separate from the main script)
    (function(){
      const ID = 'advanceButtonGlobal';
      const HOLD_MS_DEFAULT = 900;
      const MOVE_TOL = 12;

      function ensure(){ return document.getElementById(ID); }

      function attach(btn){
        if(!btn) return;
        const progressEl = btn.querySelector('.ab-progress');
        const holdDuration = Number(btn.getAttribute('data-hold-ms')) || HOLD_MS_DEFAULT;

        let pointerId = null, startX=0, startY=0, timer=null, keyTimer=null, isHolding=false;

        function startHold(px,py,pid){
          if(isHolding) return;
          isHolding=true; pointerId = pid==null?null:pid; startX=px; startY=py;
          btn.classList.add('holding'); btn.setAttribute('aria-pressed','true');
          if(progressEl){ progressEl.style.transition = 'width ' + holdDuration + 'ms linear'; setTimeout(()=>progressEl.style.width='100%', 10); }
          timer = setTimeout(()=>{ timer=null; completeHold(); }, holdDuration);
          try{ if(navigator.vibrate) navigator.vibrate(8); }catch(e){}
        }
        function cancelHold(){
          if(!isHolding) return;
          isHolding=false; pointerId=null;
          if(timer){ clearTimeout(timer); timer=null; }
          if(keyTimer){ clearTimeout(keyTimer); keyTimer=null; }
          if(progressEl){ progressEl.style.transition = 'width 160ms linear'; progressEl.style.width='0%'; }
          btn.classList.remove('holding'); btn.setAttribute('aria-pressed','false');
        }
        function completeHold(){
          cancelHold();
          const url = btn.getAttribute('data-longpress-url') || window.nextPage || '/';
          const ev = new CustomEvent('advanceActivated', { detail:{url,source:'advance-button'}, bubbles:true, cancelable:true });
          const proceed = btn.dispatchEvent(ev);
          if(!proceed) return;
          try{ window.location.href = url; }catch(e){ console.error('advance navigation failed', e); }
        }

        btn.addEventListener('contextmenu', e=>e.preventDefault());

        if(window.PointerEvent){
          btn.addEventListener('pointerdown', function(e){ if(e.isPrimary===false) return; if(e.button && e.button!==0) return; try{ btn.setPointerCapture && btn.setPointerCapture(e.pointerId); }catch(_){} startHold(e.clientX,e.clientY,e.pointerId); e.preventDefault(); }, { passive:false });
          btn.addEventListener('pointermove', function(e){ if(!isHolding) return; if(pointerId!==null && e.pointerId!==pointerId) return; const dx=Math.abs(e.clientX-startX), dy=Math.abs(e.clientY-startY); if(Math.hypot(dx,dy)>MOVE_TOL) cancelHold(); }, { passive:true });
          btn.addEventListener('pointerup', function(e){ if(!isHolding) return; if(pointerId!==null && e.pointerId!==pointerId) return; try{ btn.releasePointerCapture && btn.releasePointerCapture(e.pointerId); }catch(_){} if(timer){ clearTimeout(timer); timer=null; } cancelHold(); }, { passive:true });
          btn.addEventListener('pointercancel', function(e){ if(pointerId!==null && e.pointerId!==pointerId) return; cancelHold(); });
        } else {
          // fallbacks for older browsers / touch
          btn.addEventListener('mousedown', function(e){ if(e.button!==0) return; startHold(e.clientX,e.clientY,'mouse'); e.preventDefault(); }, { passive:false });
          document.addEventListener('mousemove', function(e){ if(!isHolding) return; const dx=Math.abs(e.clientX-startX), dy=Math.abs(e.clientY-startY); if(Math.hypot(dx,dy)>MOVE_TOL) cancelHold(); }, { passive:true });
          document.addEventListener('mouseup', function(e){ if(!isHolding) return; if(timer){ clearTimeout(timer); timer=null; } cancelHold(); }, { passive:true });
          btn.addEventListener('touchstart', function(e){ const t=e.changedTouches[0]; if(!t) return; startHold(t.clientX,t.clientY,t.identifier); e.preventDefault(); }, { passive:false });
          document.addEventListener('touchmove', function(e){ if(!isHolding) return; for(let i=0;i<e.changedTouches.length;i++){ const t=e.changedTouches[i]; if(t.identifier===pointerId){ const dx=Math.abs(t.clientX-startX), dy=Math.abs(t.clientY-startY); if(Math.hypot(dx,dy)>MOVE_TOL) cancelHold(); break; } } }, { passive:true });
          document.addEventListener('touchend', function(e){ if(!isHolding) return; for(let i=0;i<e.changedTouches.length;i++){ const t=e.changedTouches[i]; if(t.identifier===pointerId){ if(timer){ clearTimeout(timer); timer=null; } cancelHold(); break; } } }, { passive:true });
          document.addEventListener('touchcancel', function(){ if(isHolding) cancelHold(); }, { passive:true });
        }

        // keyboard support
        btn.addEventListener('keydown', function(e){
          const isSpace = (e.code === 'Space' || e.key === ' ');
          const isEnter = (e.key === 'Enter');
          if(!isSpace && !isEnter) return;
          if(keyTimer) return;
          e.preventDefault();
          btn.classList.add('holding');
          if(progressEl){ progressEl.style.transition = 'width ' + holdDuration + 'ms linear'; setTimeout(()=>progressEl.style.width='100%', 10); }
          keyTimer = setTimeout(()=>{ keyTimer=null; completeHold(); }, holdDuration);
        });
        btn.addEventListener('keyup', function(e){
          const isSpace = (e.code === 'Space' || e.key === ' ');
          const isEnter = (e.key === 'Enter');
          if((isSpace||isEnter) && keyTimer){ clearTimeout(keyTimer); keyTimer=null; if(progressEl){ progressEl.style.transition='width 160ms linear'; progressEl.style.width='0%'; } btn.classList.remove('holding'); e.preventDefault(); }
        });

        window.addEventListener('pagehide', cancelHold);
        window.addEventListener('blur', cancelHold);
      }

      // initialize after DOM ready
      if(document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', function ondom(){ document.removeEventListener('DOMContentLoaded', ondom); const btn = ensure(); attach(btn); });
      } else { const btn = ensure(); attach(btn); }
    })();
  </script>

</body>
</html>
