<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Zoom Viewer — GPU Zoom / Lens for iframes (low-CPU)</title>
  <meta name="description" content="A lightweight GPU-based zoom lens and full-viewport zoom for iframes. Works with cross-origin pages because we only transform the iframe element.">

  <style>
    :root{
      --bg: #0b0f13;
      --panel: rgba(255,255,255,0.06);
      --accent: #e9ff32;
      --control-fore: #e6eef0;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#ddd;font-family:system-ui,Arial,monospace}
    .app {
      display:flex;
      gap:12px;
      padding:12px;
      height:100vh;
      box-sizing:border-box;
    }

    /* Left: viewer area */
    .viewer {
      position:relative;
      flex:1 1 auto;
      min-width:320px;
      background:#000;
      border-radius:10px;
      overflow:hidden;
      box-shadow:0 8px 30px rgba(0,0,0,0.6);
    }

    /* iframe wrapper (normal view) */
    .frame-wrap {
      position:absolute; inset:0; overflow:hidden; background:#000;
      display:flex; align-items:stretch; justify-content:stretch;
    }
    .frame-wrap iframe {
      width:100%; height:100%; border:0; transform-origin: 0 0;
      will-change: transform; /* hint GPU */
      -webkit-transform-origin: 0 0;
      /* keep pointer events on iframe for clicks normally */
    }

    /* Lens (circular) overlay */
    .lens {
      position:absolute;
      width:220px; height:220px;
      border-radius:50%;
      overflow:hidden;
      pointer-events:auto;
      box-shadow:0 8px 20px rgba(0,0,0,0.6), 0 0 0 3px rgba(0,0,0,0.18);
      border:2px solid rgba(255,255,255,0.06);
      backdrop-filter: blur(2px);
      z-index:20;
      touch-action:none;
      display:none; /* shown when lens mode enabled */
    }
    .lens .lens-frame{
      position:absolute; left:0; top:0; width:100%; height:100%; overflow:hidden;
    }
    .lens .lens-frame iframe{
      position:absolute; left:0; top:0; width:calc(100%); height:calc(100%);
      border:0; transform-origin: 0 0; will-change: transform;
      pointer-events:none; /* pass pointer to main iframe or avoid interactions in lens */
    }

    /* UI panel */
    .panel {
      width:320px;
      max-width:40%;
      background:var(--panel);
      border-radius:10px;
      padding:12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      color:var(--control-fore);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .panel h3 { margin:0 0 6px 0; font-size:16px; color:#fff }
    .row { display:flex; gap:8px; align-items:center; }
    .row label { min-width:92px; font-size:13px; color:#cfe;}
    .row input[type=range]{ flex:1 }
    .row select, .row input[type=number]{ flex:1; padding:6px; border-radius:6px; border:0; background:rgba(255,255,255,0.03); color:#fff }
    button { padding:8px 10px; border-radius:8px; border:0; background:#0f1720; color:#e6eef0; cursor:pointer }
    button.primary { background:var(--accent); color:#012; font-weight:700 }
    .small { font-size:12px; opacity:0.9; color:#bcd }
    .muted { font-size:12px; color:#9aa; }

    /* helper for focused border when full-zoom active */
    .viewer.full-zoom-active { box-shadow: 0 12px 40px rgba(233,255,50,0.06), 0 4px 16px rgba(0,0,0,0.6) }

    @media (max-width:980px){
      .app{flex-direction:column}
      .panel{ width:100%; max-width:none }
    }
  </style>
</head>
<body>
  <div class="app">
    <div id="viewer" class="viewer" aria-live="polite">
      <div id="frameWrap" class="frame-wrap" data-mode="normal"></div>

      <!-- Lens overlay (used in lens mode) -->
      <div id="lens" class="lens" aria-hidden="true" role="presentation">
        <div class="lens-frame" id="lensFrame"></div>
      </div>
    </div>

    <div class="panel" aria-label="Zoom controls">
      <h3>Zoom Viewer (GPU)</h3>

      <div class="row">
        <label>Page</label>
        <select id="pageSelect" style="flex:1"></select>
      </div>

      <div class="row">
        <label>Mode</label>
        <select id="modeSelect" style="flex:1">
          <option value="normal">Normal</option>
          <option value="lens">Lens (follow pointer)</option>
          <option value="full">Full-page zoom</option>
        </select>
      </div>

      <div class="row">
        <label>Zoom</label>
        <input id="zoomRange" type="range" min="1" max="3" step="0.01" value="1.6">
      </div>

      <div class="row">
        <label>Lens size</label>
        <input id="lensSize" type="range" min="80" max="600" step="2" value="220">
      </div>

      <div class="row">
        <label>Follow pointer</label>
        <select id="followSelect" style="flex:1">
          <option value="pointer">Pointer</option>
          <option value="center">Center</option>
          <option value="off">Off</option>
        </select>
      </div>

      <div class="row">
        <label></label>
        <button id="autoPan" class="">Auto-pan</button>
        <button id="stopPan" class="">Stop</button>
      </div>

      <div class="row">
        <label></label>
        <button id="prevBtn">Prev</button>
        <button id="nextBtn">Next</button>
      </div>

      <div class="row small muted">
        Tip: This uses CSS transforms (GPU) only — low CPU. Cross-origin pages cannot be inspected; focus positions must be relative coordinates or pointer-driven.
      </div>

    </div>
  </div>

  <script>
  (function(){
    // --- Config: paste your URLs here (the array you provided) ---
    const pages = [
      "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch8.html",
      "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch7.html",
      "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch6.html",
      "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch3.html",
      "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch2.html"
    ];

    // --- DOM refs ---
    const frameWrap = document.getElementById('frameWrap');
    const pageSelect = document.getElementById('pageSelect');
    const modeSelect = document.getElementById('modeSelect');
    const zoomRange = document.getElementById('zoomRange');
    const lensEl = document.getElementById('lens');
    const lensFrame = document.getElementById('lensFrame');
    const viewer = document.getElementById('viewer');
    const lensSize = document.getElementById('lensSize');
    const followSelect = document.getElementById('followSelect');
    const autoPanBtn = document.getElementById('autoPan');
    const stopPanBtn = document.getElementById('stopPan');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');

    // state
    let currentIndex = 0;
    let iframeEl = null;         // the visible iframe (single)
    let lensIframe = null;       // iframe inside lens (separate element for precise zoom display)
    let zoom = parseFloat(zoomRange.value);
    let autoPanTimer = null;
    let panAnimating = false;

    // Create main iframe (single). We will reuse it for pages; transforms applied.
    function createMainIframe(url){
      frameWrap.innerHTML = '';
      const iframe = document.createElement('iframe');
      iframe.src = url;
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.border = '0';
      iframe.setAttribute('sandbox',''); // optional: remove if you need full features
      frameWrap.appendChild(iframe);
      iframeEl = iframe;
    }

    // Create lens iframe copy (separate element) — pointer interactions disabled
    function createLensIframe(url){
      lensFrame.innerHTML = '';
      const li = document.createElement('iframe');
      li.src = url;
      li.style.width = '100%';
      li.style.height = '100%';
      li.style.border = '0';
      li.style.pointerEvents = 'none';
      lensFrame.appendChild(li);
      lensIframe = li;
    }

    // populate page select
    pages.forEach((p,i)=>{
      const o = document.createElement('option');
      o.value = i;
      o.textContent = (i+1) + ': ' + p.split('/').pop();
      pageSelect.appendChild(o);
    });

    // init
    function showPage(i){
      currentIndex = ((i % pages.length) + pages.length) % pages.length;
      const url = pages[currentIndex];
      // update selects
      pageSelect.value = currentIndex;
      // set main iframe src (if same origin you could do smarter updates)
      if(!iframeEl) createMainIframe(url);
      else iframeEl.src = url;
      // lens iframe
      if(lensIframe) lensIframe.src = url;
    }

    // zoom math helpers
    // For lens: we position lens so that lens center corresponds to given page coord
    // For full: we translate iframe so focal point becomes center of viewport
    function applyFullZoom(fx, fy){
      // fx,fy in normalized [0..1] relative to iframe content
      const z = zoom;
      // size of viewport in CSS pixels:
      const vw = frameWrap.clientWidth;
      const vh = frameWrap.clientHeight;
      // We will scale iframe around top-left and translate so the focal point is centered.
      // Translate = center - focal * scale
      const focalX = fx * vw;
      const focalY = fy * vh;
      const tx = (vw/2) - focalX * z;
      const ty = (vh/2) - focalY * z;
      // apply transform: translate(tx,ty) scale(z)
      iframeEl.style.transform = `translate(${tx}px, ${ty}px) scale(${z})`;
      iframeEl.style.transformOrigin = '0 0';
    }

    function applyLensZoom(pageX, pageY){
      // pageX/Y are pointer coordinates relative to frameWrap (CSS px)
      // lens has size L; lens's iframe should be positioned such that the point under pointer maps to center of lens when scaled
      const L = parseInt(lensSize.value,10);
      lensEl.style.width = L + 'px';
      lensEl.style.height = L + 'px';
      // place lens centered on pageX/pageY
      const left = pageX - L/2;
      const top = pageY - L/2;
      lensEl.style.left = `${left}px`;
      lensEl.style.top  = `${top}px`;
      // Now compute transform for lensIframe:
      // We want the point (pageX,pageY) to map to center of lens. Because lensIframe is inside lens and sized to full viewer size,
      // we set transform = translate(-pageX + cx, -pageY + cy) scale(zoom)
      const cx = L/2, cy = L/2;
      // translate so that the page point is at lens center after scaling
      const tx = (cx - pageX) + (cx - (cx)) * 0; // simplified
      const ty = (cy - pageY);
      // Simpler: set lensIframe position absolute with same top-left as iframe, then transform scale and translate
      // We'll set lensIframe transform to translate(-pageX + cx, -pageY + cy) scale(z)
      const z = zoom;
      lensIframe.style.transformOrigin = '0 0';
      lensIframe.style.transform = `translate(${(cx - pageX)}px, ${(cy - pageY)}px) scale(${z})`;
      // Also position lensIframe so it covers the right area: ensure lensFrame size equals lensEl size and doesn't clip
      // (lensIframe is already positioned at 0,0 inside lensFrame)
    }

    // reset transforms
    function resetTransforms(){
      if(iframeEl) iframeEl.style.transform = '';
      if(lensIframe) lensIframe.style.transform = '';
    }

    // event handlers
    modeSelect.addEventListener('change', ()=> {
      const mode = modeSelect.value;
      if(mode === 'lens'){
        lensEl.style.display = 'block';
        viewer.classList.remove('full-zoom-active');
      } else if(mode === 'full'){
        lensEl.style.display = 'none';
        viewer.classList.add('full-zoom-active');
        resetTransforms();
        // center on middle by default
        applyFullZoom(0.5, 0.5);
      } else {
        lensEl.style.display = 'none';
        viewer.classList.remove('full-zoom-active');
        resetTransforms();
      }
    });

    zoomRange.addEventListener('input', ()=> {
      zoom = parseFloat(zoomRange.value);
      // update transforms depending on mode
      if(modeSelect.value === 'full'){
        // if following pointer, use center or last mouse pos
        applyFullZoom(lastNormX || 0.5, lastNormY || 0.5);
      } else if(modeSelect.value === 'lens'){
        // update lens transform at current position
        if(lastPos) applyLensZoom(lastPos.x, lastPos.y);
      }
    });

    lensSize.addEventListener('input', ()=>{
      if(lastPos) applyLensZoom(lastPos.x, lastPos.y);
    });

    pageSelect.addEventListener('change', (e)=>{
      showPage(Number(e.target.value));
    });

    prevBtn.addEventListener('click', ()=> showPage(currentIndex - 1));
    nextBtn.addEventListener('click', ()=> showPage(currentIndex + 1));

    // pointer tracking
    let lastPos = null;
    let lastNormX = 0.5, lastNormY = 0.5;
    function onPointerMove(e){
      const rect = frameWrap.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      lastPos = { x, y };
      lastNormX = x / rect.width;
      lastNormY = y / rect.height;
      if(modeSelect.value === 'lens'){
        if(followSelect.value === 'pointer'){
          applyLensZoom(x, y);
        } else if(followSelect.value === 'center'){
          const cx = rect.width/2, cy = rect.height/2;
          applyLensZoom(cx, cy);
        }
      } else if(modeSelect.value === 'full'){
        if(followSelect.value === 'pointer'){
          applyFullZoom(lastNormX, lastNormY);
        } else if(followSelect.value === 'center'){
          applyFullZoom(0.5, 0.5);
        }
      }
    }

    frameWrap.addEventListener('pointermove', onPointerMove);
    frameWrap.addEventListener('touchmove', (ev)=> {
      if(ev.touches && ev.touches[0]) onPointerMove(ev.touches[0]);
    }, { passive:false });

    // drag lens by pointerdown on lens itself
    let draggingLens = false, dragOffsetX=0, dragOffsetY=0;
    lensEl.addEventListener('pointerdown', (e)=>{
      draggingLens = true;
      const rect = lensEl.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      e.preventDefault();
    });
    window.addEventListener('pointermove', (e)=>{
      if(!draggingLens) return;
      const rect = frameWrap.getBoundingClientRect();
      const x = e.clientX - rect.left - dragOffsetX + lensEl.clientWidth/2;
      const y = e.clientY - rect.top - dragOffsetY + lensEl.clientHeight/2;
      lastPos = { x, y };
      applyLensZoom(x, y);
    });
    window.addEventListener('pointerup', ()=> draggingLens = false);

    // auto-pan: animate focus point across page randomly or in grid
    autoPanBtn.addEventListener('click', ()=>{
      if(panAnimating) return;
      panAnimating = true;
      autoPan(0);
    });
    stopPanBtn.addEventListener('click', ()=>{
      panAnimating = false;
    });

    function autoPan(step){
      if(!panAnimating) return;
      // pick a new normalized focal point (avoid edges)
      const nx = 0.15 + Math.random()*0.7;
      const ny = 0.15 + Math.random()*0.7;
      const steps = 24;
      animateFocusTo(nx, ny, steps, ()=> {
        setTimeout(()=> {
          if(panAnimating) autoPan(step+1);
        }, 350 + Math.random()*1500);
      });
    }

    function animateFocusTo(normX, normY, steps=16, cb){
      // Animate from lastNormX/Y to target in discrete steps using requestAnimationFrame
      const startX = lastNormX || 0.5, startY = lastNormY || 0.5;
      let t = 0;
      function step(){
        t++;
        const p = t/steps;
        // ease in-out
        const ease = p<0.5 ? 2*p*p : -1 + (4 - 2*p)*p;
        const curX = startX + (normX - startX) * ease;
        const curY = startY + (normY - startY) * ease;
        lastNormX = curX; lastNormY = curY;
        if(modeSelect.value === 'full') applyFullZoom(curX, curY);
        else if(modeSelect.value === 'lens') {
          const rect = frameWrap.getBoundingClientRect();
          const px = curX * rect.width;
          const py = curY * rect.height;
          applyLensZoom(px, py);
        }
        if(t < steps) requestAnimationFrame(step);
        else {
          if(typeof cb === 'function') cb();
        }
      }
      requestAnimationFrame(step);
    }

    // pause media in iframe via postMessage (cooperative on target pages)
    btnPauseMedia.addEventListener('click', ()=>{
      try{ iframeEl && iframeEl.contentWindow && iframeEl.contentWindow.postMessage({type:'rotator:pause-media'}, '*'); }catch(e){}
      try{ lensIframe && lensIframe.contentWindow && lensIframe.contentWindow.postMessage({type:'rotator:pause-media'}, '*'); }catch(e){}
    });

    // keyboard: space toggles mode between normal and full for quick test
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'z'){ // quick toggle full zoom
        modeSelect.value = (modeSelect.value === 'full') ? 'normal' : 'full';
        modeSelect.dispatchEvent(new Event('change'));
      }
      if(e.key === ']' ) showPage(currentIndex + 1);
      if(e.key === '[' ) showPage(currentIndex - 1);
    });

    // initial show
    showPage(0);

    // expose helper
    window.zoomViewer = { showPage, applyFullZoom, applyLensZoom };
  })();
  </script>
</body>
</html>
