<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CUSeeMe — Experimental Rotator (Jeff Gompertz)</title>

  <style>
    :root{
      --dur: 900ms;
      --ease: cubic-bezier(.2,.8,.2,1);
      --panel-bg: rgba(0,0,0,0.48);
      --accent: #e9ff32;
    }
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,monospace}
    .rot-wrap{position:fixed;inset:0;overflow:hidden;background:#000}
    .container{position:relative;width:100%;height:100%}
    .rot-frame{
      position:absolute;inset:0;opacity:0;pointer-events:none;
      transition: transform var(--dur,900ms) var(--ease), opacity var(--dur,900ms) var(--ease), filter var(--dur,900ms) var(--ease);
      transform-origin:center center; will-change:transform,opacity,filter; backface-visibility:hidden;
      z-index:1;
      background:#111;
    }
    .rot-frame iframe{width:100%;height:100%;border:0;display:block}
    .rot-frame.active{opacity:1;pointer-events:auto;z-index:3}
    .rot-frame.prev{z-index:2}

    /* effects */
    .container.fx-zoom-in .rot-frame.prev{ transform: scale(1.06); opacity:0; filter: blur(1.5px) }
    .container.fx-zoom-out .rot-frame.prev{ transform: scale(.86); opacity:0; filter: blur(1.5px) }
    .container.fx-flip .rot-frame.prev{ transform: rotateY(70deg) translateZ(-40px); opacity:0 }
    .container.fx-slide .rot-frame.prev{ transform: translateX(-6%) scale(.98); opacity:0 }
    .container.fx-spin .rot-frame.prev{ transform: rotate(18deg) scale(.82); opacity:0 }

    /* UI */
    .rot-ui{position:fixed;right:12px;top:12px;z-index:10010;background:var(--panel-bg);padding:8px;border-radius:8px;color:#fff;font-family:system-ui}
    .rot-ui .row{display:flex;gap:6px;align-items:center;margin-bottom:6px}
    .rot-ui button, .rot-ui select, .rot-ui input[type=range]{background:rgba(255,255,255,0.04);color:#fff;border:0;padding:6px 8px;border-radius:6px;cursor:pointer}
    .meta{position:fixed;left:12px;bottom:12px;z-index:10010;background:rgba(0,0,0,0.36);padding:6px 10px;border-radius:8px;font-size:13px}

    @media (max-width:720px){ .rot-ui{ right:8px; top:8px; min-width:150px } }
  </style>
</head>
<body>
  <div class="rot-wrap">
    <div id="rotContainer" class="container fx-zoom-in" style="--dur:900ms">
      <!-- The script will create and use up to poolSize iframe slots and lazy-load the listed URLs -->
    </div>
  </div>

  <div class="rot-ui" aria-hidden="false">
    <div class="row">
      <button id="rotPrev">◀ Prev</button>
      <button id="rotPlay">▶ Play</button>
      <button id="rotNext">Next ▶</button>
    </div>
    <div class="row">
      <label style="color:#ddd">Effect</label>
      <select id="rotEffect">
        <option value="zoom-in">zoom-in</option>
        <option value="zoom-out">zoom-out</option>
        <option value="flip">flip</option>
        <option value="slide">slide</option>
        <option value="spin">spin</option>
        <option value="random">random</option>
      </select>
    </div>
    <div class="row">
      <label style="color:#ddd">Speed</label>
      <input id="rotSpeed" type="range" min="300" max="3000" step="100" value="900">
    </div>
    <div class="row">
      <button id="rotShuffle">Shuffle</button>
      <button id="rotPauseMedia">Pause media</button>
    </div>
  </div>

  <div class="meta">Index: <span id="idx">0</span> / <span id="total">0</span> — Effect: <span id="currentEffect">zoom-in</span></div>

  <div id="ticker" style="display:none"></div>

<script>
/*
  Rotator script (pool-based, lazy iframe loading). No screenshots.
  Pool size = 2 (keeps memory low). Prefetch next shortly before transition.
  Usage: initRotator(urlArray);
*/
(function(){
  const container = document.getElementById('rotContainer');
  const idxEl = document.getElementById('idx');
  const totalEl = document.getElementById('total');
  const currentEffectLabel = document.getElementById('currentEffect');

  // controls
  const btnPrev = document.getElementById('rotPrev');
  const btnNext = document.getElementById('rotNext');
  const btnPlay = document.getElementById('rotPlay');
  const selEffect = document.getElementById('rotEffect');
  const speedInput = document.getElementById('rotSpeed');
  const btnShuffle = document.getElementById('rotShuffle');
  const btnPauseMedia = document.getElementById('rotPauseMedia');

  // configurable
  const poolSize = 2;
  const prefetchMs = 500;

  // state
  let urls = [];
  let index = 0;
  let duration = Number(speedInput.value) || 900;
  let playing = false;
  let timer = null;
  let mode = 'sequential'; // or 'random'

  // pool slots
  const pool = [];

  function createSlot(){
    const slotEl = document.createElement('div');
    slotEl.className = 'rot-frame';
    const iframe = document.createElement('iframe');
    iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = '0';
    slotEl.appendChild(iframe);
    container.appendChild(slotEl);
    return { slotEl, iframe, url:null, busy:false };
  }

  for(let i=0;i<poolSize;i++) pool.push(createSlot());

  function pickSlot(exclude){
    let s = pool.find(p => !p.busy && p !== exclude);
    if(!s) s = pool[0];
    return s;
  }

  function loadIntoSlot(slot, url, timeoutMs=5000){
    return new Promise((resolve)=>{
      slot.busy = true;
      slot.url = url;
      // recreate iframe for clean load
      const old = slot.iframe;
      const iframe = document.createElement('iframe');
      iframe.style.width='100%'; iframe.style.height='100%'; iframe.style.border='0';
      slot.slotEl.replaceChild(iframe, old);
      slot.iframe = iframe;
      let done = false;
      function onLoad(){
        if(done) return; done=true;
        iframe.removeEventListener('load', onLoad);
        slot.busy = false;
        resolve(true);
      }
      iframe.addEventListener('load', onLoad);
      try{ iframe.src = url; }catch(e){ slot.busy=false; resolve(false); return; }
      setTimeout(()=>{ if(done) return; done=true; iframe.removeEventListener('load', onLoad); slot.busy=false; resolve(false); }, timeoutMs);
    });
  }

  function clearPrevClasses(){
    pool.forEach(p => p.slotEl.classList.remove('prev'));
  }

  function showAt(i, effectName){
    if(urls.length === 0) return;
    i = ((i % urls.length) + urls.length) % urls.length;
    const chosenUrl = urls[i];
    const existing = pool.find(p => p.url === chosenUrl);
    const selEffectValue = (effectName === 'random') ? ['zoom-in','zoom-out','flip','slide','spin'][Math.floor(Math.random()*5)] : (effectName || selEffect.value || 'zoom-in');
    container.className = 'container fx-' + selEffectValue;
    currentEffectLabel.textContent = selEffectValue;

    // mark previous
    const prev = pool.find(p => p.slotEl.classList.contains('active'));
    if(prev){ prev.slotEl.classList.remove('active'); prev.slotEl.classList.add('prev'); }

    const slot = existing || pickSlot(prev);
    const ready = (slot.url === chosenUrl && slot.iframe && slot.iframe.src);
    const loadPromise = ready ? Promise.resolve(true) : loadIntoSlot(slot, chosenUrl, Math.max(2000, duration+200));
    loadPromise.finally(()=>{
      pool.forEach(p => p.slotEl.classList.remove('active'));
      slot.slotEl.classList.add('active');
      index = i;
      idxEl.textContent = index + 1;
      totalEl.textContent = urls.length;
      // tidy prev class shortly after transition
      setTimeout(()=> clearPrevClasses(), duration + 100);
    });
  }

  function nextIndex(){
    if(mode === 'random') return Math.floor(Math.random()*urls.length);
    return (index + 1) % urls.length;
  }
  function prevIndex(){
    if(mode === 'random') return Math.floor(Math.random()*urls.length);
    return (index - 1 + urls.length) % urls.length;
  }

  function prefetchNext(){
    if(urls.length <= 1) return;
    const nxt = (index + 1) % urls.length;
    const url = urls[nxt];
    if(pool.some(p => p.url === url)) return;
    const slot = pickSlot();
    setTimeout(()=> loadIntoSlot(slot, url, 5000).then(()=>{}), prefetchMs);
  }

  function scheduleNext(){
    if(timer) clearTimeout(timer);
    timer = setTimeout(()=>{
      const nxt = nextIndex();
      showAt(nxt, selEffect.value);
      prefetchNext();
      if(playing) scheduleNext();
    }, duration);
  }

  function startAuto(){ if(playing) return; playing = true; btnPlay.textContent='Pause'; scheduleNext(); }
  function stopAuto(){ playing = false; btnPlay.textContent='Play'; if(timer){ clearTimeout(timer); timer=null; } }

  // controls
  btnNext.addEventListener('click', ()=>{ stopAuto(); showAt(nextIndex(), selEffect.value); prefetchNext(); });
  btnPrev.addEventListener('click', ()=>{ stopAuto(); showAt(prevIndex(), selEffect.value); prefetchNext(); });
  btnPlay.addEventListener('click', ()=>{ if(playing) stopAuto(); else startAuto(); });
  selEffect.addEventListener('change', ()=>{ container.className = 'container fx-' + selEffect.value; currentEffectLabel.textContent = selEffect.value; });
  speedInput.addEventListener('input', ()=>{ duration = Number(speedInput.value); container.style.setProperty('--dur', duration+'ms'); });
  btnShuffle.addEventListener('click', ()=>{ mode = (mode==='sequential') ? 'random' : 'sequential'; addTicker('mode:'+mode); });
  btnPauseMedia.addEventListener('click', ()=>{ framesPostMessage({type:'rotator:pause-media'}); addTicker('pause-media posted'); });

  function framesPostMessage(msg){
    pool.forEach(s=>{
      try{ s.iframe && s.iframe.contentWindow && s.iframe.contentWindow.postMessage(msg,'*'); }catch(e){}
    });
  }
  function addTicker(msg){ if(window.console) console.log('rotator:',msg); }

  // public init
  window.initRotator = function(list, options = {}){
    urls = Array.isArray(list) ? list.slice() : [];
    if(options.poolSize && Number.isInteger(options.poolSize) && options.poolSize > 0){
      // NOTE: this simple build does not recreate the pool dynamically after document load.
      // The included file uses poolSize=2 by default; to change pool size rebuild page with different constant.
    }
    if(urls.length === 0) return;
    // show the first
    showAt(0, selEffect.value);
    prefetchNext();
  };

  // useful console helpers
  window.rotatorControl = { showAt, startAuto, stopAuto, prefetchNext, setUrls: (u)=>{ initRotator(u); } };

})(); // end rotator IIFE
</script>

<!-- Initialize with your 5 GitHub Pages URLs (paste as-is) -->
<script>
  initRotator([
    "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch8.html",
    "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch7.html",
    "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch6.html",
    "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch3.html",
    "https://jeff-gompertz.github.io/CUseeme/videotemplate/test_run_inject_touch2.html"
  ]);
  // Optionally start autoplay:
  // window.rotatorControl.startAuto();
</script>

</body>
</html>
