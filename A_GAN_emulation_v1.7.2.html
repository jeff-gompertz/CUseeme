<style>
  :root{--acid:#e9ff32;--line:rgba(255,255,255,.14);--soft:rgba(255,255,255,.68);--glass:rgba(0,0,0,.72);--bg:#000;}
  #ganWrap{background:var(--bg);color:#fff;font-family:Helvetica,Arial,sans-serif;}
  #ganWrap, #ganWrap *{pointer-events:auto !important;}
  #ganWrap{position:relative;z-index:999999 !important;}

  /* LAYOUT: residue first, then app */
  #ganPage{min-height:100vh;display:flex;flex-direction:column;gap:14px;padding:14px;box-sizing:border-box;}
  .panel{border:1px solid rgba(233,255,50,.22);background:var(--glass);border-radius:16px;box-shadow:0 18px 60px rgba(0,0,0,.55);overflow:hidden;min-height:0;}
  .head{padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.10);}
  .title{letter-spacing:.18em;text-transform:uppercase;color:rgba(233,255,50,.75);font-size:12px;margin:0 0 6px;}
  .big{margin:0;color:var(--acid);font-size:22px;font-weight:900;line-height:1.1;}
  .meta{margin-top:8px;color:var(--soft);font-size:13px;line-height:1.4;}
  .meta code{color:rgba(233,255,50,.92);}
  .body{padding:12px 14px;overflow:auto;min-height:0;}

  /* Residue strip */
  #residuePanel .body{padding:12px 12px 14px;}
  #residueStrip{
    display:flex; gap:10px; overflow-x:auto; overflow-y:hidden;
    scroll-snap-type:x mandatory; padding-bottom:8px;
  }
  #residueStrip::-webkit-scrollbar{height:10px;}
  #residueStrip::-webkit-scrollbar-thumb{background:rgba(233,255,50,.22);border-radius:999px;}
  .rItem{
    flex:0 0 auto; width:140px; height:140px;
    border-radius:14px; border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.04);
    overflow:hidden; cursor:pointer;
    scroll-snap-align:start;
    position:relative;
  }
  .rItem img{width:100%;height:100%;object-fit:cover;display:block;transform:scale(1.02);}
  .rCap{
    position:absolute; left:0; right:0; bottom:0;
    padding:6px 8px;
    font-size:11px;
    background:linear-gradient(to top, rgba(0,0,0,.75), rgba(0,0,0,0));
    color:rgba(233,255,50,.9);
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }
  #residueEmpty{color:rgba(233,255,50,.65);font-size:13px;padding:10px 2px;}

  /* App grid below residue */
  #ganAppGrid{
    display:grid;
    grid-template-columns: minmax(320px, 420px) 1fr minmax(360px, 520px);
    gap:14px;
    min-height:0;
  }

  /* Controls */
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px;}
  button.gbtn{
    cursor:pointer;border-radius:14px;padding:12px 14px;border:1px solid rgba(255,255,255,.22);
    background:rgba(0,0,0,.6);color:#fff;font-weight:900;letter-spacing:.12em;text-transform:uppercase;
    font-size:12px;-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none;
  }
  button.gbtn.primary{border-color:rgba(233,255,50,.45);color:var(--acid);}
  button.gbtn[disabled]{opacity:.45;cursor:default;}

  .pill{font-size:12px;color:rgba(255,255,255,.70);border:1px solid rgba(255,255,255,.18);padding:6px 10px;border-radius:999px;}
  .pill strong{color:var(--acid);}

  #ganDrop{margin-top:12px;border:1px dashed rgba(233,255,50,.35);border-radius:14px;padding:12px;color:rgba(233,255,50,.78);background:rgba(0,0,0,.35);font-size:12px;line-height:1.35;}
  #ganDrop.on{border-color:rgba(233,255,50,.85);box-shadow:0 0 0 1px rgba(233,255,50,.10) inset;}
  #ganFile{position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;}

  canvas{width:100%;height:auto;display:block;border-radius:14px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.03);}
  textarea{
    width:100%;height:170px;box-sizing:border-box;background:rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.18);color:rgba(233,255,50,.9);
    border-radius:12px;padding:10px;font:12px/1.35 ui-monospace,Menlo,Monaco,Consolas,monospace;white-space:pre;
  }
  input[type="range"]{width:180px;}
  input[type="text"]{
    width:100%;box-sizing:border-box;border-radius:12px;border:1px solid rgba(255,255,255,.18);
    background:rgba(0,0,0,.45);color:#fff;padding:10px;font-size:13px;outline:none;
  }

  /* Collapsible “advanced” */
  details{margin-top:12px;border:1px solid rgba(255,255,255,.12);border-radius:14px;overflow:hidden;background:rgba(0,0,0,.20);}
  summary{cursor:pointer;list-style:none;padding:12px 12px;color:rgba(233,255,50,.82);font-weight:900;letter-spacing:.08em;text-transform:uppercase;font-size:12px;}
  summary::-webkit-details-marker{display:none;}
  details .inner{padding:0 12px 12px;}

  @media (max-width: 1100px){
    #ganAppGrid{grid-template-columns:1fr; }
  }
</style>

<div id="ganWrap">
  <div id="ganPage">

    <!-- 1) RESIDUE FIRST (enticing) -->
    <div id="residuePanel" class="panel">
      <div class="head">
        <div class="title">Residue pile (public)</div>
        <div class="big">Latest artifacts</div>
        <div class="meta">Scroll sideways. Click any thumbnail to bring it forward into <b>Selected</b> (right panel) without needing a ZIP.</div>
      </div>
      <div class="body">
        <div id="residueStrip"></div>
        <div id="residueEmpty" style="display:none;">No residue yet. Publish a selection to seed the pile.</div>
      </div>
    </div>

    <!-- 2) MAIN APP -->
    <div id="ganAppGrid">

      <!-- LEFT: INPUTS (not a demo—full fields, but compact) -->
      <div class="panel">
        <div class="head">
          <div class="title">Inputs</div>
          <div class="big" id="ganStatus">Awaiting ZIP</div>
          <div class="meta">If you don’t have a ZIP ready, you can still explore by clicking residue above.</div>
        </div>
        <div class="body">

          <div class="row">
            <button class="gbtn primary" id="ganChooseBtn" type="button">Choose ZIP</button>
            <button class="gbtn" id="ganRunBtn" type="button" disabled>Run Once</button>
            <button class="gbtn" id="ganStopBtn" type="button" disabled>Stop</button>
          </div>

          <div class="row">
            <span class="pill">Dataset: <strong id="ganDsId">—</strong></span>
            <span class="pill">Count: <strong id="ganCount">0</strong></span>
            <span class="pill">Gen: <strong id="ganStep">0</strong></span>
          </div>

          <div class="meta" style="margin-top:12px;">Prompt</div>
          <input id="ganPrompt" type="text" value="uncanny latent hybrid, smeared identity, exquisite corpse, imperfect memory, liminal portrait" />

          <div class="row" style="align-items:center;">
            <span class="pill">Strength: <strong id="ganStrengthVal">0.75</strong></span>
            <input id="ganStrength" type="range" min="0.35" max="0.95" step="0.01" value="0.75" />
          </div>

          <div id="ganDrop">Drop ZIP here (images inside). Or tap “Choose ZIP”.</div>
          <input id="ganFile" type="file" accept=".zip,application/zip" />

          <details open>
            <summary>Logs + endpoints</summary>
            <div class="inner">
              <div class="row" style="margin-top:0;">
                <button class="gbtn" id="ganCopyLog" type="button">Copy log</button>
                <button class="gbtn" id="ganClearLog" type="button">Clear log</button>
              </div>

              <div class="row">
                <span class="pill">img2img: <strong id="ganEp1">—</strong></span>
                <span class="pill">poll: <strong id="ganEp2">—</strong></span>
              </div>

              <textarea id="ganLog" readonly></textarea>
            </div>
          </details>

        </div>
      </div>

      <!-- MID: CONTACT SHEET -->
      <div class="panel">
        <div class="head">
          <div class="title">Contact sheet</div>
          <div class="big" id="ganCsTitle">No dataset yet</div>
          <div class="meta" id="ganCsMeta">Load a ZIP and it appears here (seed).</div>
        </div>
        <div class="body">
          <canvas id="ganContact" width="1400" height="1400"></canvas>
        </div>
      </div>

      <!-- RIGHT: OUTPUT + SELECTION -->
      <div class="panel">
        <div class="head">
          <div class="title">Output + selection</div>
          <div class="big" id="ganRunTitle">Idle</div>
          <div class="meta" id="ganRunMeta">Run Once sends seed to GPU. Click a tile to select.</div>
        </div>
        <div class="body">
          <div class="meta">Output grid (click a tile):</div>
          <canvas id="ganMain" width="1024" height="1024"></canvas>

          <div class="meta" style="margin-top:12px;">Selected (foreground):</div>
          <canvas id="ganSelected" width="1024" height="1024"></canvas>

          <div class="row" style="margin-top:10px;">
            <button class="gbtn" id="ganDownloadSel" type="button" disabled>Download Selected</button>
            <button class="gbtn primary" id="ganPublishSel" type="button" disabled>Publish Selected</button>
            <button class="gbtn primary" id="ganHiRes" type="button" disabled>Hi-Res from Selected</button>
            <button class="gbtn" id="ganPublishHi" type="button" disabled>Publish Hi-Res</button>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
(() => {
  const $ = (id)=>document.getElementById(id);

  const API_BASE = "https://art.jeffgompertz.site";

  const EP_IMG2IMG = new URL("/wp-json/ganemulator/v1/img2img", API_BASE || window.location.origin).toString();
  const EP_POLL    = new URL("/wp-json/ganemulator/v1/poll",    API_BASE || window.location.origin).toString();
  const EP_RESIDUE = new URL("/wp-json/ganemulator/v1/residue?limit=30", API_BASE || window.location.origin).toString();
  const EP_SAVE    = new URL("/wp-json/ganemulator/v1/save",            API_BASE || window.location.origin).toString();
  const EP_SAVE_HI = new URL("/wp-json/ganemulator/v1/save_hi",         API_BASE || window.location.origin).toString();

  $('ganEp1').textContent = EP_IMG2IMG.replace(/^https?:\/\//,'');
  $('ganEp2').textContent = EP_POLL.replace(/^https?:\/\//,'');

  const logEl = $('ganLog');
  function log(line){
    const ts = new Date().toISOString().slice(11,19);
    logEl.value += `[${ts}] ${line}\n`;
    logEl.scrollTop = logEl.scrollHeight;
    console.log(line);
  }

  $('ganCopyLog').addEventListener('click', async ()=>{
    try{ await navigator.clipboard.writeText(logEl.value); log("copied log to clipboard ✅"); }
    catch(e){ log("copy failed (clipboard blocked)"); }
  });
  $('ganClearLog').addEventListener('click', ()=>{ logEl.value=""; });

  const chooseBtn = $('ganChooseBtn');
  const runBtn    = $('ganRunBtn');
  const stopBtn   = $('ganStopBtn');
  const fileEl    = $('ganFile');
  const drop      = $('ganDrop');

  const status    = $('ganStatus');
  const dsIdEl    = $('ganDsId');
  const countEl   = $('ganCount');
  const stepEl    = $('ganStep');

  const csTitle   = $('ganCsTitle');
  const csMeta    = $('ganCsMeta');
  const runTitle  = $('ganRunTitle');
  const runMeta   = $('ganRunMeta');

  const promptEl  = $('ganPrompt');
  const strengthEl= $('ganStrength');
  const strengthVal = $('ganStrengthVal');
  strengthEl.addEventListener('input', ()=>{ strengthVal.textContent = (+strengthEl.value).toFixed(2); });
  strengthVal.textContent = (+strengthEl.value).toFixed(2);

  const contact   = $('ganContact');
  const cctx      = contact.getContext('2d', { willReadFrequently:true });

  const main      = $('ganMain');
  const mctx      = main.getContext('2d', { willReadFrequently:true });

  const selected  = $('ganSelected');
  const sctx      = selected.getContext('2d', { willReadFrequently:true });

  const btnDL     = $('ganDownloadSel');
  const btnPub    = $('ganPublishSel');
  const btnHi     = $('ganHiRes');
  const btnPubHi  = $('ganPublishHi');

  function cleanId(name){
    const base = (name||"dataset").toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
    return ("ds_" + base).slice(0, 40);
  }

  async function blobToSquareBitmap(blob, size=256){
    try{
      const img = await createImageBitmap(blob);
      const c = document.createElement('canvas');
      c.width=size; c.height=size;
      const ctx=c.getContext('2d');
      const s=Math.min(img.width,img.height);
      const sx=(img.width-s)/2, sy=(img.height-s)/2;
      ctx.drawImage(img,sx,sy,s,s,0,0,size,size);
      const outBlob = await new Promise(r=>c.toBlob(r,'image/jpeg',0.92));
      return await createImageBitmap(outBlob);
    }catch(e){ return null; }
  }

  function chooseGrid(count){
    if (count>=256) return 16;
    if (count>=144) return 12;
    if (count>=100) return 10;
    if (count>=64)  return 8;
    return 6;
  }

  function renderContactSheet(images, grid=12){
    const n = Math.min(images.length, grid*grid);
    const W = contact.width;
    const cell = Math.floor(W/grid);
    contact.height = W;
    cctx.fillStyle="#000";
    cctx.fillRect(0,0,W,W);
    for (let i=0;i<n;i++){
      const x=(i%grid)*cell;
      const y=Math.floor(i/grid)*cell;
      cctx.drawImage(images[i],x,y,cell,cell);
    }
  }

  async function postJson(url, obj){
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type":"application/json" },
      body: JSON.stringify(obj)
    });
    const ct = (res.headers.get("content-type") || "").toLowerCase();
    const raw = await res.text();
    log(`POST ${new URL(url).pathname} → http ${res.status} ct=${ct || "(none)"}`);
    return { res, ct, raw };
  }

  async function pollPrediction(id){
    for (let i=0;i<50;i++){
      await new Promise(r=>setTimeout(r, 1500));
      const { ct, raw } = await postJson(EP_POLL, { id });
      if (!ct.includes("application/json")) return { ok:false, error:"bad_json_head", head: raw.slice(0,200) };
      const json = JSON.parse(raw);
      if (!json.ok) return { ok:false, error: json.error || "poll_failed", json };
      const pred = json.prediction;
      if (pred && pred.status === "succeeded") return { ok:true, prediction: pred };
      if (pred && pred.status === "failed") return { ok:false, error:"prediction_failed", prediction: pred };
    }
    return { ok:false, error:"poll_timeout" };
  }

  async function drawReturnedImage(url){
    return new Promise((resolve)=>{
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = ()=>{
        mctx.setTransform(1,0,0,1,0,0);
        mctx.clearRect(0,0,main.width,main.height);
        mctx.drawImage(img, 0, 0, main.width, main.height);
        log("GPU image drawn ✅");
        resolve(true);
      };
      img.onerror = ()=>{ log("GPU image load failed"); resolve(false); };
      img.src = url;
    });
  }

  function downloadDataURL(dataURL, filename){
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  async function urlToDataURL(url){
    const r = await fetch(url);
    const b = await r.blob();
    return await new Promise(resolve=>{
      const fr = new FileReader();
      fr.onload = ()=>resolve(fr.result);
      fr.readAsDataURL(b);
    });
  }

  async function drawToSelected(dataURL){
    return new Promise((resolve)=>{
      const img = new Image();
      img.onload = ()=>{
        sctx.setTransform(1,0,0,1,0,0);
        sctx.clearRect(0,0,selected.width,selected.height);
        const scale = Math.min(selected.width/img.width, selected.height/img.height);
        const w = img.width*scale;
        const h = img.height*scale;
        const ox = (selected.width-w)/2;
        const oy = (selected.height-h)/2;
        sctx.drawImage(img, ox, oy, w, h);
        resolve(true);
      };
      img.src = dataURL;
    });
  }

  // --- state ---
  let datasetId="", datasetName="", datasetImages=[];
  let step=0;
  let lastSeedDataURL=null;
  let selectedTileDataURL=null;
  let hiResDataURL=null;
  const GRID_N = 8;

  function enableSelectionButtons(on){
    btnDL.disabled  = !on;
    btnPub.disabled = !on;
    btnHi.disabled  = !on;
  }
  function enableHiButtons(on){
    btnPubHi.disabled = !on;
  }

  // Residue strip loader (public) — FIRST THING users see
  async function loadResidue(){
    try{
      const r = await fetch(EP_RESIDUE);
      const j = await r.json();
      if (!j.ok) throw new Error("residue_not_ok");

      const strip = document.getElementById('residueStrip');
      const empty = document.getElementById('residueEmpty');
      strip.innerHTML = "";

      if (!j.items || !j.items.length){
        empty.style.display = "block";
        return;
      }
      empty.style.display = "none";

      j.items.forEach(item=>{
        const d = document.createElement('div');
        d.className = "rItem";
        const img = document.createElement('img');
        img.src = item.url;
        img.alt = item.dataset_id || "residue";
        const cap = document.createElement('div');
        cap.className = "rCap";
        cap.textContent = (item.kind ? item.kind.toUpperCase() : "RESIDUE") + " • " + (item.dataset_id || "ds");
        d.appendChild(img);
        d.appendChild(cap);

        d.addEventListener('click', async ()=>{
          const data = await urlToDataURL(item.url);
          selectedTileDataURL = data;
          hiResDataURL = null;
          await drawToSelected(selectedTileDataURL);
          enableSelectionButtons(true);
          enableHiButtons(false);
          runTitle.textContent = "Selected";
          runMeta.textContent = "From residue pile (public).";
          log("selected from residue ✅");
        });

        strip.appendChild(d);
      });

      log("residue loaded ✅ (" + j.items.length + ")");
    } catch(e){
      log("residue load failed");
    }
  }

  // Output click -> pick tile from main canvas
  main.addEventListener('click', (e)=>{
    const rect = main.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (main.width / rect.width);
    const y = (e.clientY - rect.top) * (main.height / rect.height);

    const tileW = main.width / GRID_N;
    const tileH = main.height / GRID_N;

    const tx = Math.floor(x / tileW);
    const ty = Math.floor(y / tileH);

    const crop = document.createElement('canvas');
    crop.width = 256; crop.height = 256;
    const cx = crop.getContext('2d');
    cx.imageSmoothingEnabled = true;
    cx.drawImage(main, tx * tileW, ty * tileH, tileW, tileH, 0, 0, crop.width, crop.height);

    selectedTileDataURL = crop.toDataURL("image/jpeg", 0.92);
    hiResDataURL = null;
    drawToSelected(selectedTileDataURL);
    enableSelectionButtons(true);
    enableHiButtons(false);
    log(`tile selected: (${tx},${ty})`);
  });

  // Publish selected to residue
  btnPub.addEventListener('click', async ()=>{
    if (!selectedTileDataURL) return;
    btnPub.disabled = true;
    log("publishing selected…");
    const payload = { dataset_id: datasetId || "ds_public", kind: "selected", note: "user selected", data: selectedTileDataURL };
    const { ct, raw } = await postJson(EP_SAVE, payload);
    if (!ct.includes("application/json")) { log("publish failed: bad_json"); btnPub.disabled=false; return; }
    const j = JSON.parse(raw);
    if (!j.ok) { log("publish failed: " + (j.error||"unknown")); btnPub.disabled=false; return; }
    log("published ✅ " + j.url);
    btnPub.disabled = false;
    loadResidue();
  });

  // Download selected
  btnDL.addEventListener('click', ()=>{
    if (!selectedTileDataURL) return;
    downloadDataURL(selectedTileDataURL, `gan_selected_${Date.now()}.jpg`);
    log("downloaded selected ✅");
  });

  // Hi-res from selected (GPU handshake)
  btnHi.addEventListener('click', async ()=>{
    if (!selectedTileDataURL) return;
    btnHi.disabled = true;
    runTitle.textContent = "Hi-Res";
    runMeta.textContent = "Sending selected to GPU…";
    log("hi-res request…");

    const payload = {
      image: selectedTileDataURL,
      prompt: (promptEl.value || "uncanny latent hybrid"),
      strength: +strengthEl.value,
      width: 1024,
      height: 1024,
      num_inference_steps: 40
    };

    const { ct, raw } = await postJson(EP_IMG2IMG, payload);
    if (!ct.includes("application/json")) { log("hi-res error: bad_json"); btnHi.disabled=false; return; }
    const j = JSON.parse(raw);
    if (!j.ok || !j.prediction || !j.prediction.id){
      log("hi-res error: no prediction id");
      btnHi.disabled=false;
      return;
    }

    log("hi-res prediction id: " + j.prediction.id);
    const polled = await pollPrediction(j.prediction.id);
    if (!polled.ok){ log("hi-res poll error: " + polled.error); btnHi.disabled=false; return; }

    const out = polled.prediction.output;
    const url = Array.isArray(out) ? out[0] : out;
    if (!url){ log("hi-res no output url"); btnHi.disabled=false; return; }

    hiResDataURL = await urlToDataURL(url);
    await drawToSelected(hiResDataURL);
    enableHiButtons(true);
    log("hi-res ready ✅");
    btnHi.disabled=false;
  });

  // Publish hi-res to residue
  btnPubHi.addEventListener('click', async ()=>{
    if (!hiResDataURL) return;
    btnPubHi.disabled = true;
    log("publishing hi-res…");
    const payload = { dataset_id: datasetId || "ds_public", kind: "hires", note: "hi-res from selected", data: hiResDataURL };
    const { ct, raw } = await postJson(EP_SAVE_HI, payload);
    if (!ct.includes("application/json")) { log("publish hi failed: bad_json"); btnPubHi.disabled=false; return; }
    const j = JSON.parse(raw);
    if (!j.ok) { log("publish hi failed: " + (j.error||"unknown")); btnPubHi.disabled=false; return; }
    log("published hi ✅ " + j.url);
    btnPubHi.disabled = false;
    loadResidue();
  });

  stopBtn.addEventListener('click', ()=>{
    runTitle.textContent="Idle";
    runMeta.textContent="Stopped.";
    log("stopped");
  });

  // ZIP input
  chooseBtn.addEventListener('click', (e)=>{
    e.preventDefault(); e.stopPropagation();
    fileEl.value="";
    fileEl.click();
    log("choose click fired");
  }, { capture:true });

  fileEl.addEventListener('change', async ()=>{
    const f = fileEl.files && fileEl.files[0];
    if (!f){ log("file picker closed (no file)"); return; }
    await ingestZip(f);
    fileEl.value="";
  });

  ['dragenter','dragover'].forEach(evt=>{
    drop.addEventListener(evt,(e)=>{e.preventDefault();e.stopPropagation();drop.classList.add('on');});
  });
  ['dragleave','drop'].forEach(evt=>{
    drop.addEventListener(evt,(e)=>{e.preventDefault();e.stopPropagation();drop.classList.remove('on');});
  });
  drop.addEventListener('drop', async (e)=>{
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (!f) return;
    if (!/zip/i.test(f.type) && !/\.zip$/i.test(f.name)){
      status.textContent="Not a ZIP";
      log("drop rejected: not a zip");
      return;
    }
    await ingestZip(f);
  });

  async function ingestZip(zipFile){
    status.textContent="Reading ZIP…";
    runTitle.textContent="Idle";
    runMeta.textContent="Decoding images…";
    log(`zip loaded: ${zipFile.name}`);

    const ab = await zipFile.arrayBuffer();
    const zip = await JSZip.loadAsync(ab);

    const entries=[];
    zip.forEach((path,file)=>{
      if (file.dir) return;
      const ext = path.split('.').pop().toLowerCase();
      if (['jpg','jpeg','png','webp','gif'].includes(ext)) entries.push(file);
    });

    if (!entries.length){
      status.textContent="No images found";
      log("zip contained no images");
      return;
    }

    const picked=entries.slice(0,500);
    datasetName = zipFile.name.replace(/\.[^.]+$/,'');
    datasetId = cleanId(datasetName);
    datasetImages=[];
    step=0; stepEl.textContent="0";

    for (let i=0;i<picked.length;i++){
      const blob = await picked[i].async('blob');
      const bmp = await blobToSquareBitmap(blob,256);
      if (bmp) datasetImages.push(bmp);
      if ((i+1)%30===0) log(`decoded ${i+1}/${picked.length}`);
    }

    dsIdEl.textContent = datasetId;
    countEl.textContent = String(datasetImages.length);

    status.textContent="Dataset ready";
    csTitle.textContent = `Dataset: ${datasetName}`;
    csMeta.innerHTML = `Contact sheet from <code>${datasetImages.length}</code> images.`;

    renderContactSheet(datasetImages, chooseGrid(datasetImages.length));
    log("contact sheet rendered ✅");

    lastSeedDataURL = contact.toDataURL("image/jpeg", 0.90);

    runBtn.disabled=false;
    stopBtn.disabled=false;
    runMeta.textContent="Run Once sends seed to GPU.";
    log("endpoints: img2img=" + EP_IMG2IMG);
    log("endpoints: poll=" + EP_POLL);
  }

  runBtn.addEventListener('click', async ()=>{
    if (!lastSeedDataURL){ log("no seed yet"); return; }

    runBtn.disabled=true;
    runTitle.textContent="Running";
    runMeta.textContent="Sending seed to GPU…";
    status.textContent="Running…";

    const payload = { image: lastSeedDataURL, prompt: (promptEl.value || "uncanny latent hybrid"), strength: +strengthEl.value };

    log("Sending POST request…");
    const { ct, raw } = await postJson(EP_IMG2IMG, payload);

    if (!ct.includes("application/json")){
      runTitle.textContent="GPU error";
      runMeta.textContent="bad_json";
      log("GPU error: bad_json_head: " + raw.slice(0,200));
      runBtn.disabled=false;
      return;
    }

    const j = JSON.parse(raw);
    if (!j.ok || !j.prediction || !j.prediction.id){
      runTitle.textContent="GPU error";
      runMeta.textContent="No prediction ID";
      log("GPU error: No prediction ID");
      runBtn.disabled=false;
      return;
    }

    log("Prediction id: " + j.prediction.id);
    runMeta.textContent="Polling…";
    const polled = await pollPrediction(j.prediction.id);

    if (!polled.ok){
      runTitle.textContent="GPU error";
      runMeta.textContent=polled.error;
      log("GPU error: " + polled.error);
      runBtn.disabled=false;
      return;
    }

    const out = polled.prediction.output;
    const url = Array.isArray(out) ? out[0] : out;
    if (!url){
      runTitle.textContent="GPU error";
      runMeta.textContent="No output URL";
      log("GPU error: no output url");
      runBtn.disabled=false;
      return;
    }

    await drawReturnedImage(url);

    step++;
    stepEl.textContent = String(step);
    runTitle.textContent="Done";
    runMeta.textContent="Click a tile to select it.";

    // feedback: next run uses last GPU output as seed
    lastSeedDataURL = await urlToDataURL(url);
    log("seed updated = last GPU output ✅");

    runBtn.disabled=false;
  });

  // BOOT
  log("client ready: Choose ZIP");
  loadResidue();
})();
</script>