<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CUSeeMe Modular v1.2 â€” Interactive (TTS + Semantic)</title>

<style>
/* =========================================================
   [L6: GLOBAL STYLE SYSTEM]
========================================================= */
:root{
  --base-bg: #ffffff;
  --ui-fg:  #0a0a0a;
  --glass:  rgba(255,255,255,0.22);
  --glass-b: rgba(0,0,0,0.18);
  --ticker-color: #FF4433;      /* locked red */
}
html,body{
  margin:0;height:100%;overflow:hidden;background:var(--base-bg);
  font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
  color:var(--ui-fg);
}

/* =========================================================
   [L0: MAIN CAMERA]
========================================================= */
#cameraMain{
  position:fixed;inset:0;object-fit:cover;
  transform:scaleX(-1);  /* mirror default */
  z-index:0;
}

/* =========================================================
   [L1: HUD (upper-right, frosted)]
========================================================= */
/* === HUD container â€” iOS-style frosted rounded === */
#hud {
  position: fixed;
  top: 14px;
  right: 14px;
  z-index: 10;
  display: grid;
  gap: 8px;
  grid-auto-rows: min-content;
  background: rgba(255,255,255,0.15);
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 14px;
  backdrop-filter: blur(10px);
  padding: 10px 12px;
  min-width: 240px;
  color: #111;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
  box-shadow: 0 8px 30px rgba(0,0,0,0.2);
}



/* =========================================================
   [L3: DIAGNOSTIC TICKER â€” bottom-left]
========================================================= */
#ticker{
  position:fixed;left:12px;bottom:12px;z-index:8;
  width:42vw;max-width:640px;max-height:56vh;
  display:flex;flex-direction:column-reverse;overflow:hidden;pointer-events:none;
  color:var(--ticker-color);font-size:1.2rem;line-height:1.3rem;opacity:.9;
}
.tline{opacity:.9;margin:0;animation:tlIn .6s ease forwards}
@keyframes tlIn{from{opacity:0;transform:translateY(8px)}to{opacity:.9;transform:none}}

/* =========================================================
   [L4: INPUT PROMPT â€” centered overlay]
========================================================= */
#promptWrap{
  position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
  z-index:6;pointer-events:none;
}
#promptBox{
  pointer-events:auto;display:flex;gap:.5rem;align-items:center;
  background:rgba(255,255,255,.22);backdrop-filter:blur(6px);
  border:1px solid rgba(0,0,0,.18);border-radius:12px;
  padding:.7rem 1rem;font-size:1.6rem;
}
#caret{width:.3ch;height:1.3em;background:#111;animation:blink 1s step-end infinite}
@keyframes blink{50%{opacity:0}}
#input{
  background:transparent;border:none;outline:none;width:18ch;color:#111;font:inherit;
}
#input::placeholder{color:rgba(0,0,0,.35)}

/* =========================================================
   [L5: FLOATING MINI-FEED â€” draggable window]
========================================================= */

/* =========================================================
   [L5: FLOATING MINI-FEED â€” Portrait Frosted Version]
========================================================= */
#miniWin{
  position: fixed;
  z-index: 7;
  left: 8vw; top: 10vh;
  height: 60vh;
  aspect-ratio: 9 / 16;              /* ðŸ“± portrait window */
  display: none;

  background: rgba(255,255,255,0.08);  /* frosted translucent bezel */
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 18px;
  box-shadow: 0 20px 50px rgba(0,0,0,0.25);
  backdrop-filter: blur(12px);
  overflow: hidden;
  cursor: grab;
  transition: transform .2s ease, box-shadow .2s ease;
}
#miniWin:active { cursor: grabbing; transform: scale(1.02); box-shadow: 0 25px 70px rgba(0,0,0,0.3); }

#miniBar{
  display:flex;align-items:center;justify-content:space-between;
  padding:4px 10px;
  background:rgba(255,255,255,0.15);
  font-size:12px;color:#222;
}
#miniTitle{font-weight:600;opacity:.7;}
#miniBtns{display:flex;gap:4px;}
.win-dot{width:6px;height:6px;border-radius:50%;background:#999;opacity:.7;}

#miniInner{position:relative;width:100%;height:calc(100% - 24px);}
#cameraMini{
  position:absolute;inset:0;object-fit:cover;
  width:100%;height:100%;transform:scaleX(-1);
}

</style>
</head>
<body>

<!-- [L0] MAIN CAMERA -->
<video id="cameraMain" autoplay muted playsinline></video>

<!-- [L1] HUD -->
<div id="hud">
  <h1>Signal Shell</h1>
  <div class="hud-row">
    <button class="hud-btn active" id="btnToggleMini">âž• Mini-Feed</button>
    <button class="hud-btn" id="btnMirrorMain">Mirror Main</button>
    <button class="hud-btn" id="btnMirrorMini" disabled>Mirror Mini</button>
  </div>
  <div class="hud-row">
    <button class="hud-btn" id="btnMiniGrow">Mini +</button>
    <button class="hud-btn" id="btnMiniShrink">Mini âˆ’</button>
    <button class="hud-btn" id="btnVoice">Voice: Off</button>
  </div>
  <div class="hud-row">
    <button class="hud-btn" id="btnReset">Reset</button>
  </div>
</div>

<!-- [L3] TICKER -->
<div id="ticker"></div>

<!-- [L4] PROMPT -->
<div id="promptWrap">
  <div id="promptBox">
    <div id="caret"></div>
    <input id="input" type="text" placeholder="type hereâ€¦" spellcheck="false" autocomplete="off" />
  </div>
</div>

<!-- [L5] MINI FEED -->
<div id="miniWin" aria-label="mini feed window">
  <div id="miniBar">
    <div id="miniTitle">subject_0001</div>
    <div id="miniBtns"><div class="win-dot"></div><div class="win-dot"></div><div class="win-dot"></div></div>
  </div>
  <div id="miniInner">
    <video id="cameraMini" autoplay muted playsinline></video>
  </div>
</div>

<script>
/* =========================================================
   UTIL â€” ticker lines
========================================================= */
const ticker = document.getElementById('ticker');
function addTicker(text){
  const line = document.createElement('div');
  line.className = 'tline';
  line.textContent = text;
  ticker.prepend(line);
  if(ticker.children.length > 80) ticker.removeChild(ticker.lastChild);
  setTimeout(()=>line.style.opacity=.25, 60000);
}

/* Boot messages */
['link /optical established','loopback handshake ok','field integrity 99.2%','ui shell ready','ticker: online']
  .forEach((m,i)=>setTimeout(()=>addTicker(m), 300*i));

/* =========================================================
   CAMERA INIT (shared stream)
========================================================= */
const vMain = document.getElementById('cameraMain');
const vMini = document.getElementById('cameraMini');
let mediaStream = null;

(async ()=>{
  try{
    mediaStream = await navigator.mediaDevices.getUserMedia({video:true,audio:false});
    vMain.srcObject = mediaStream;
    vMini.srcObject  = mediaStream;
    addTicker('camera stream: granted');
  }catch(e){
    addTicker('âš  camera denied');
  }
})();

/* =========================================================
   INPUT â†’ ticker (delegates reply to Semantic Engine)
========================================================= */
const input = document.getElementById('input');
function handleSubmit(value){
  const val = value.trim();
  if(!val) return;
  addTicker('> ' + val);
  input.value = '';
  const reply = semanticReply(val);           // MODULE B
  setTimeout(()=>{
    addTicker('< ' + reply);
    if(voiceOn) speak(reply);                 // MODULE A (replies only)
  }, 550);
}
input.addEventListener('keydown', e=>{
  if(e.key==='Enter'){ e.preventDefault(); handleSubmit(input.value); }
});
input.addEventListener('input', e=>{
  if(e.inputType==='insertLineBreak'){ e.preventDefault?.(); handleSubmit(input.value); }
});

/* =========================================================
   HUD wires
========================================================= */
const btnMini   = document.getElementById('btnToggleMini');
const btnMirrorMain = document.getElementById('btnMirrorMain');
const btnMirrorMini = document.getElementById('btnMirrorMini');
const btnGrow   = document.getElementById('btnMiniGrow');
const btnShrink = document.getElementById('btnMiniShrink');
const btnReset  = document.getElementById('btnReset');
const btnVoice  = document.getElementById('btnVoice');
const miniWin   = document.getElementById('miniWin');

btnMini.addEventListener('click', ()=>{
  const on = miniWin.style.display !== 'block';
  miniWin.style.display = on ? 'block' : 'none';
  btnMirrorMini.disabled = !on;
  btnMini.classList.toggle('active', on);
  addTicker(on ? 'mini-feed: shown' : 'mini-feed: hidden');
});

/* Mirror toggles */
let mirrorMain = true, mirrorMini = true;
btnMirrorMain.addEventListener('click', ()=>{
  mirrorMain = !mirrorMain;
  vMain.style.transform = mirrorMain ? 'scaleX(-1)' : 'none';
  btnMirrorMain.classList.toggle('active', !mirrorMain);
  addTicker(`mirror main: ${mirrorMain?'on':'off'}`);
});
btnMirrorMini.addEventListener('click', ()=>{
  mirrorMini = !mirrorMini;
  vMini.style.transform = mirrorMini ? 'scaleX(-1)' : 'none';
  btnMirrorMini.classList.toggle('active', !mirrorMini);
  addTicker(`mirror mini: ${mirrorMini?'on':'off'}`);
});

/* Size controls */
function setMiniScale(mult){
  const r = miniWin.getBoundingClientRect();
  const w = Math.max(220, Math.min(innerWidth*0.7, r.width*mult));
  miniWin.style.width = w + 'px';
}
btnGrow.addEventListener('click', ()=>setMiniScale(1.1));
btnShrink.addEventListener('click', ()=>setMiniScale(0.9));

/* Reset defaults */
btnReset.addEventListener('click', ()=>{
  input.value='';
  mirrorMain=true; vMain.style.transform='scaleX(-1)';
  mirrorMini=true; vMini.style.transform='scaleX(-1)';
  btnMirrorMain.classList.remove('active');
  btnMirrorMini.classList.remove('active');
  miniWin.style.left='6vw'; miniWin.style.top='10vh'; miniWin.style.width='38vw';
  addTicker('reset: shell defaults');
});

/* Drag mini window */
(function(){
  const bar = document.getElementById('miniBar');
  let dragging=false, sx=0, sy=0, sl=0, st=0;
  function start(e){
    dragging=true;
    const r=miniWin.getBoundingClientRect();
    sl=r.left; st=r.top;
    sx=(e.touches?e.touches[0].clientX:e.clientX);
    sy=(e.touches?e.touches[0].clientY:e.clientY);
    document.addEventListener('pointermove',move);
    document.addEventListener('pointerup',stop);
    document.addEventListener('touchmove',move,{passive:false});
    document.addEventListener('touchend',stop);
  }
  function move(e){
    if(!dragging) return;
    const cx=(e.touches?e.touches[0].clientX:e.clientX);
    const cy=(e.touches?e.touches[0].clientY:e.clientY);
    miniWin.style.left = (sl + (cx-sx))+'px';
    miniWin.style.top  = (st + (cy-sy))+'px';
    e.preventDefault?.();
  }
  function stop(){
    dragging=false;
    document.removeEventListener('pointermove',move);
    document.removeEventListener('pointerup',stop);
    document.removeEventListener('touchmove',move);
    document.removeEventListener('touchend',stop);
  }
  bar.addEventListener('pointerdown',start);
  bar.addEventListener('touchstart',start,{passive:false});
})();

/* =========================================================
   MODULE A â€” TEXT-TO-SPEECH (replies only)
========================================================= */
let voiceOn = false;           // default OFF (toggle in HUD)
let voicesReady = false;

function primeVoices(){
  return new Promise(res=>{
    const tid = setInterval(()=>{
      const v = speechSynthesis.getVoices();
      if(v && v.length){ clearInterval(tid); voicesReady = true; res(); }
    },100);
  });
}
async function speak(text){
  if(!voiceOn || !('speechSynthesis' in window)) return;
  if(!voicesReady) await primeVoices();
  const u = new SpeechSynthesisUtterance(text);
  u.lang='en-US'; u.rate=1.05; u.pitch=0.9; u.volume=0.85;
  const v = speechSynthesis.getVoices();
  u.voice = v.find(x=>/samantha/i.test(x.name)) || v.find(x=>/google/i.test(x.name)) || v[0];
  speechSynthesis.speak(u);
}
/* iOS unlock on first touch/click */
function unlockTTS(){
  try{ speechSynthesis.speak(new SpeechSynthesisUtterance('')); speechSynthesis.cancel(); }catch(e){}
  window.removeEventListener('touchstart',unlockTTS);
  window.removeEventListener('click',unlockTTS);
}
window.addEventListener('touchstart',unlockTTS,{once:true});
window.addEventListener('click',unlockTTS,{once:true});

/* HUD toggle for voice */
btnVoice.addEventListener('click', ()=>{
  voiceOn = !voiceOn;
  btnVoice.textContent = voiceOn ? 'Voice: On' : 'Voice: Off';
  btnVoice.classList.toggle('active', voiceOn);
  addTicker(`voice synth: ${voiceOn?'enabled':'disabled'}`);
});

/* =========================================================
   MODULE B â€” SEMANTIC REPLY ENGINE (concise diagnostics)
========================================================= */
function semanticReply(input){
  const t = input.toLowerCase();

  // quick keyword buckets
  const greet = /(hello|hi|hey|yo|hola)/;
  const video = /(video|camera|feed|frame|mirror|mini)/;
  const sys   = /(link|signal|sync|handshake|latency|ping|bandwidth)/;
  const ask   = /(why|how|what|when|where)/;
  const ok    = /(ok|okay|good|great|works|working)/;
  const warn  = /(error|fail|broken|issue|bug|stuck)/;
  const size  = /(bigger|smaller|zoom|scale)/;

  if (greet.test(t)) return 'acknowledged: uplink active';
  if (video.test(t)) return 'video path: stable; mirror channel ready';
  if (sys.test(t))   return `field sync nominal; latency ${(Math.random()*40+20|0)}ms`;
  if (size.test(t))  return 'scaler engaged: adjust via mini Â± controls';
  if (ok.test(t))    return 'status: green; continuing stream';
  if (warn.test(t))  return 'diagnostic: retry suggested; check permissions';
  if (ask.test(t))   return 'referencing local map: route prepared';

  // default neutral reply
  const corr = Math.floor(Math.random()*100);
  return `signal correlation ${corr}%`;
}
</script>
</body>
</html>
