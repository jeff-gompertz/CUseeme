<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Baseline Touch + Recursive Trails</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }

  /* Floating windows */
  .floating-window {
    position: absolute;
    width: 240px;
    height: 160px;
    overflow: hidden;
    border: none;
    cursor: grab;
    background: rgba(255,255,255,0.1);
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    touch-action: none;
    -webkit-user-select: none;
            user-select: none;
    -webkit-touch-callout: none;
  }

  .floating-window:active { cursor: grabbing; }

  .floating-window img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    pointer-events: none;
  }

  canvas#feedback {
    position: fixed;
    inset: 0;
    z-index: -1;
  }
</style>
</head>
<body>

<canvas id="feedback"></canvas>
<div id="windows"></div>

<script>
const container = document.getElementById("windows");
const canvas = document.getElementById("feedback");
const ctx = canvas.getContext("2d");
function resizeCanvas(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
window.addEventListener("resize", resizeCanvas); resizeCanvas();

const feedUrl =
  "https://www.youtube.com/feeds/videos.xml?channel_id=UCREEmHdAYvlboosrKCHe4UA";

let windows = [];

fetch("https://api.rss2json.com/v1/api.json?rss_url=" + encodeURIComponent(feedUrl))
  .then(res => res.json())
  .then(data => {
    const items = (data.items || []).slice(0, 5);
    items.forEach((video,i) => {
      const div = document.createElement("div");
      div.className = "floating-window";
      div.style.left = (50 + i*260) + "px";
      div.style.top  = (50 + i*180) + "px";

      const vid = (video.guid || "").split(":").pop();
      const thumb = video.thumbnail || `https://i.ytimg.com/vi/${vid}/hqdefault.jpg`;
      div.innerHTML = `<img src="${thumb}" alt="thumb">`;

      container.appendChild(div);
      makeDraggable(div);
      windows.push(div);
    });
    animate();
  });

function makeDraggable(el){
  let dragging=false, offsetX=0, offsetY=0;
  el.addEventListener("pointerdown",e=>{
    dragging=true;
    offsetX=e.clientX-el.offsetLeft;
    offsetY=e.clientY-el.offsetTop;
    el.setPointerCapture(e.pointerId);
  });
  el.addEventListener("pointermove",e=>{
    if(!dragging)return;
    el.style.left=(e.clientX-offsetX)+"px";
    el.style.top =(e.clientY-offsetY)+"px";
  });
  el.addEventListener("pointerup",e=>{
    dragging=false;
    try{ el.releasePointerCapture(e.pointerId);}catch{}
  });
}

function animate(){
  requestAnimationFrame(animate);

  // Recursive feedback: draw canvas onto itself with fade
  ctx.fillStyle = "rgba(0,0,0,0.1)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(canvas, -1, -1, canvas.width+2, canvas.height+2);

  // Draw all windows into feedback layer
  windows.forEach(el=>{
    ctx.drawImage(el, el.offsetLeft, el.offsetTop, el.offsetWidth, el.offsetHeight);
  });
}
</script>
</body>
</html>
