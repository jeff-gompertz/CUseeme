<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Shadertest with Trails</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; }
  canvas { width:100%; height:100%; display:block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec2 a_position;
varying vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
uniform float u_time;
uniform sampler2D u_prevFrame;
varying vec2 v_uv;

void main() {
  // Base color field (like shadertest)
  vec2 uv = v_uv;
  float color = 0.5 + 0.5 * sin(u_time + uv.x*6.2831 + uv.y*3.1415);
  vec3 base = vec3(color, 0.3+0.7*uv.x, 0.3+0.7*uv.y);

  // Fetch previous frame (for trails)
  vec3 prev = texture2D(u_prevFrame, uv).rgb;

  // Mix current frame with faded previous frame
  vec3 final = mix(base, prev, 0.90);  // 0.90 = long trail, lower = shorter

  gl_FragColor = vec4(final, 1.0);
}
</script>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Compile shader
function compileShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
  }
  return s;
}

// Setup shaders
const vsSource = document.getElementById("vertex-shader").text;
const fsSource = document.getElementById("fragment-shader").text;
const vs = compileShader(gl.VERTEX_SHADER, vsSource);
const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
gl.useProgram(prog);

// Quad
const verts = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, "a_position");
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uTime = gl.getUniformLocation(prog, "u_time");
const uPrev = gl.getUniformLocation(prog, "u_prevFrame");

// Framebuffer for trails
function createTex() {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0,
                gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  return tex;
}
function createFBO(tex) {
  const fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  return fbo;
}

const texA = createTex();
const texB = createTex();
const fboA = createFBO(texA);
const fboB = createFBO(texB);
let flip = false;

// Draw loop
function render(time) {
  const t = time * 0.001;
  const srcTex = flip ? texA : texB;
  const dstFBO = flip ? fboB : fboA;

  gl.bindFramebuffer(gl.FRAMEBUFFER, dstFBO);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.uniform1f(uTime, t);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, srcTex);
  gl.uniform1i(uPrev, 0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  // Present to screen
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, dstFBO === fboA ? texA : texB);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

  flip = !flip;
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
