<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mode A — Optical Flow Node Field (Corrected)</title>
<style>
html,body{
  margin:0; padding:0;
  height:100vh; width:100vw;
  overflow:hidden;
  background:#000;
}

/* Live camera filling screen */
#cam {
  position:fixed;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  transform:scaleX(-1);
  z-index:0;
}

/* Node canvas */
#flow {
  position:fixed;
  inset:0;
  z-index:2;
  pointer-events:none;
}

/* Debug label */
#debugLabel{
  position:fixed;
  top:10px; left:10px;
  z-index:100;
  padding:4px 8px;
  font-family:monospace;
  font-size:12px;
  border-radius:3px;
  background:rgba(0,200,50,0.12);
  color:#0f0;
  display:none;
}
</style>
</head>
<body>

<video id="cam" autoplay muted playsinline></video>
<canvas id="flow"></canvas>
<div id="debugLabel">DEBUG: ON</div>

<script>
/* =========================================================
  MODE A — Optical Flow (Corrected)
========================================================= */

const cam = document.getElementById("cam");
const flowCanvas = document.getElementById("flow");
const fctx = flowCanvas.getContext("2d");

// Offscreen buffer for optical flow sampling
const off = document.createElement("canvas");
const offctx = off.getContext("2d");

// Node grid settings
const SPACING = 22;     // grid density
const SENSITIVITY = 18; // motion sensitivity
const FORCE = 0.15;     // response strength

let nodes = [];
let debug = true;

// Toggle debug with "D"
document.addEventListener("keydown", e=>{
  if(e.key.toLowerCase()==="d"){
    debug = !debug;
    document.getElementById("debugLabel").style.display = debug?"block":"none";
  }
});

function resize(){
  flowCanvas.width = window.innerWidth;
  flowCanvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// Build node grid (screen-space positions)
function makeNodes(){
  nodes = [];
  for(let y=SPACING/2; y<flowCanvas.height; y+=SPACING){
    for(let x=SPACING/2; x<flowCanvas.width; x+=SPACING){
      nodes.push({
        x, y,
        vx:0, vy:0
      });
    }
  }
}

/* =========================================================
  CAMERA INIT
========================================================= */
async function initCam(){
  const stream = await navigator.mediaDevices.getUserMedia({
    video:{facingMode:{ideal:"environment"}},
    audio:false
  });
  cam.srcObject = stream;

  return new Promise(res=>{
    cam.onloadedmetadata=()=>res();
  });
}

/* =========================================================
  MOTION SAMPLING
========================================================= */
function computeFlow(){

  // Match offscreen buffer to real video resolution
  off.width = cam.videoWidth;
  off.height = cam.videoHeight;

  // Draw current frame into offscreen canvas
  offctx.drawImage(cam,0,0,off.width,off.height);

  const img = offctx.getImageData(0,0,off.width,off.height).data;

  // Optical flow per node
  nodes.forEach(n=>{
    // Map node.x/y (screen) -> video resolution (offscreen)
    const sx = Math.floor((n.x / flowCanvas.width)  * off.width);
    const sy = Math.floor((n.y / flowCanvas.height) * off.height);

    const i = (sy*off.width + sx)*4;

    // Simple luminance for now (can be replaced by Sobel)
    const lum = (img[i] + img[i+1] + img[i+2]) / 3;

    // Store previous lum if missing
    if(n.prevLum === undefined){
      n.prevLum = lum;
      return;
    }

    // Motion = difference between frames at this pixel
    const diff = lum - n.prevLum;
    n.prevLum = lum;

    const a = diff / SENSITIVITY; // impulse force

    // Apply some directional scattering
    const angle = ((sx*13 + sy*7) % 360) * (Math.PI/180);

    n.vx += Math.cos(angle) * a * FORCE;
    n.vy += Math.sin(angle) * a * FORCE;

    // Damping
    n.vx *= 0.94;
    n.vy *= 0.94;

    // Integrate
    n.x += n.vx;
    n.y += n.vy;
  });
}

/* =========================================================
  DRAW FLOW NODES
========================================================= */
function draw(){
  fctx.clearRect(0,0,flowCanvas.width,flowCanvas.height);

  if(debug){
    fctx.fillStyle="rgba(0,255,0,0.8)";
    nodes.forEach(n=>{
      fctx.beginPath();
      fctx.arc(n.x,n.y,2,0,Math.PI*2);
      fctx.fill();
    });
  }
}

/* =========================================================
  MAIN LOOP
========================================================= */
function loop(){
  computeFlow();
  draw();
  requestAnimationFrame(loop);
}

/* =========================================================
  BOOT
========================================================= */
(async function(){
  await initCam();
  makeNodes();
  document.getElementById("debugLabel").style.display = "block";
  loop();
})();
</script>
</body>
</html>
