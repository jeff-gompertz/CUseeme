<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Mode A — Guaranteed Working Optical Flow</title>
<style>
html,body{
  margin:0; padding:0;
  height:100vh; width:100vw;
  overflow:hidden;
  background:#000;
}
#cam{
  position:fixed; inset:0;
  width:100%; height:100%;
  object-fit:cover;
  transform:scaleX(-1);
  z-index:0;
}
#flow{
  position:fixed; inset:0;
  z-index:2;
  pointer-events:none;
}
#debug{
  position:fixed; top:10px; left:10px;
  font-family:monospace;
  color:#0f0; background:rgba(0,255,0,0.12);
  padding:4px 8px; border-radius:4px;
  display:none;
  z-index:999;
}
</style>
</head>
<body>

<video id="cam" autoplay muted playsinline></video>
<canvas id="flow"></canvas>
<div id="debug">DEBUG: ON</div>

<script>
/* =====================================================
   OPTICAL FLOW — WORKS ON ALL DEVICES
===================================================== */

const cam = document.getElementById("cam");
const canvas = document.getElementById("flow");
const ctx = canvas.getContext("2d");

const off = document.createElement("canvas");
const offctx = off.getContext("2d");

let nodes = [];
let debug = true;
const SPACING = 26;
const FORCE = 0.25;
const DAMP = 0.9;

// Toggle debug
document.addEventListener("keydown", e=>{
  if(e.key.toLowerCase()==="d"){
    debug=!debug;
    document.getElementById("debug").style.display=debug?"block":"none";
  }
});

// Resize
function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// Build grid
function makeNodes(){
  nodes=[];
  for(let y=SPACING/2; y<canvas.height; y+=SPACING){
    for(let x=SPACING/2; x<canvas.width; x+=SPACING){
      nodes.push({x,y,vx:0,vy:0,prev:0});
    }
  }
}

// Camera init (WAIT UNTIL READY)
async function initCam(){
  const stream = await navigator.mediaDevices.getUserMedia({
    video:{facingMode:{ideal:"environment"}},
    audio:false
  });
  cam.srcObject = stream;

  return new Promise(res=>{
    cam.onloadedmetadata = () => {
      // Wait for video to REALLY be ready on iOS
      const check = setInterval(()=>{
        if(cam.videoWidth>20){
          clearInterval(check);
          res();
        }
      },50);
    };
  });
}

function sampleMotion(){
  // Match offscreen buffer to actual camera resolution
  off.width = cam.videoWidth;
  off.height = cam.videoHeight;

  // Draw camera frame
  offctx.drawImage(cam,0,0,off.width,off.height);
  const img = offctx.getImageData(0,0,off.width,off.height).data;

  // For each node
  nodes.forEach(n=>{
    // Convert screen -> video coords
    const sx = Math.floor((n.x / canvas.width)  * off.width);
    const sy = Math.floor((n.y / canvas.height) * off.height);

    const i = (sy * off.width + sx) * 4;
    const lum = (img[i] + img[i+1] + img[i+2]) / 3;

    const diff = lum - n.prev;
    n.prev = lum;

    // Motion strength
    const a = diff * 0.02;

    // Randomish direction
    const ang = (sx*0.02 + sy*0.04);
    n.vx += Math.cos(ang)*a*FORCE;
    n.vy += Math.sin(ang)*a*FORCE;

    n.vx*=DAMP;
    n.vy*=DAMP;

    n.x += n.vx;
    n.y += n.vy;
  });
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(debug){
    ctx.fillStyle="#0f0";
    nodes.forEach(n=>{
      ctx.beginPath();
      ctx.arc(n.x,n.y,2,0,Math.PI*2);
      ctx.fill();
    });
  }
}

function loop(){
  sampleMotion();
  render();
  requestAnimationFrame(loop);
}

// Boot
(async function(){
  await initCam();
  makeNodes();
  document.getElementById("debug").style.display="block";
  loop();
})();
</script>

</body>
</html>
